<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>我理想中的笔记软件-trilium</title>
    <link href="/2022/11/01/%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6-trilium/"/>
    <url>/2022/11/01/%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6-trilium/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从去年开始我就一直尝试各种笔记软件，从一开始使用的以有道云笔记，印象笔记为代表的传统笔记软件；到开始产生数据安全意识，转而使用以joplin、obsidian、logseq为代表的本地笔记软件。</p><p>此期间尝试了无数笔记软件，陪伴我最久的是obsidian。这是一款十分优秀的本地markdown笔记软件，而且扩展性极佳，使用插件可以实现各种各样的功能。</p><p>当然问题也出在这里，使用obsidian后我的关注力似乎更多的在于折腾软件这件事上而不是进行知识沉淀。我总是思考如何使用插件和标签等构建更好的工作流，我总是疲于折腾，实际沉淀下的知识却甚少。</p><p>而且同步问题确实有些糟心，我之前写了一个小工具用于解决使用icloud同步时产生碎片文件的问题，可是icloud总是会带来各种各样意料之外的诡异问题。后来尝试使用git进行版本管理，但是经常性的处理冲突文件也逐渐让我疲惫。多终端的频繁同步也让git的版本管理失去了意义。</p><p>最让我欣喜的是logseq，logseq的一大特点就是取消了传统的目录结构，转而从每日笔记作为切入点，构建笔记之间的双链关系。这样的好处是可以减少记笔记时的心理负担，我们不需要思考从何开始动笔，需要做的只是在每日笔记中记下今日的工作或者灵感。</p><p>这与我心中的工作流十分接近。但缺少目录结构的整理归纳，无数的笔记碎片会使整个笔记系统变得一团糟，虽然使用logseq的query能解决部分问题，但总是没有目录结构来的清晰明了。</p><p>接下来该提到trilium了，很久以前就听闻这是一个可以构建无限节点的知识库笔记，但是我一直没有尝试。这次把trilium作为主力笔记软件使用一个月后，我认为trilium足以成为我理想中的笔记软件。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>这是一款在github上开源的笔记软件，附上链接：<a href="https://github.com/zadam/trilium">zadam&#x2F;trilium</a>。不过我使用的是国人翻译后重新编译的版本，附上链接：<a href="https://github.com/Nriver/trilium-translation">Nriver&#x2F;trilium-translation</a>。</p><p>开源、多端同步、功能丰富的编辑器(CKEditor 5)、双向链接、无限层级……这些特点足以让人一试。</p><h1 id="我的工作流"><a href="#我的工作流" class="headerlink" title="我的工作流"></a>我的工作流</h1><p>如上所述，trilium的特点有很多，但只是一条一条叙述的话未免枯燥乏味，不如直接看<a href="https://github.com/zadam/trilium/wiki">wiki文档</a>来的清楚明白。</p><p>所以我以自己的工作流为切入点介绍一下我所使用到的笔记特点。</p><h2 id="从日记出发"><a href="#从日记出发" class="headerlink" title="从日记出发"></a>从日记出发</h2><p>上文说过logseq的以日记为笔记的切入点的思路非常适合我，所以我每天首先会做的就是开启一篇日记，写下今日的代办计划。同obsidian一样，trilium也支持从模板创建，使用<code>~template:&lt;日记模板&gt;</code>标签即可用模板中的内容自动创建日记。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101144406.png"></p><p>这一天当中所有的笔记我都会附在今日日记的下方，这体现出trilium的一个特点，它没有文件夹的概念，取而代之的是节点，每一个节点都可以编辑和新增子节点，就像一颗可以无限成长的树，向外蔓延出无数枝干。</p><p>就像这样：<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101145052.png"></p><p>这是我今日看书时在脑海中闪现的想法，此时无需考虑如何分类如何关联，直接在今日日记下进行记录即可。在记录这种类型的笔记时，我参考了《卡片笔记法》的概念，每一个节点中只记录一个想法，如果是读书笔记的话，则贴上原文片段。</p><p>浏览网页的时候看到有意思的文章时则用网页剪裁插件，一键剪裁到今日日记下方。</p><h2 id="整理归纳"><a href="#整理归纳" class="headerlink" title="整理归纳"></a>整理归纳</h2><p>一天下来，今日日记的下方肯定产生了许多子节点，如果放任不管的话，我们的记录便失去了意义。所以一天结束时我会对今日记录的内容做分类。</p><p>说到这里不得不提到trilium的克隆功能，接触过双向链接的小伙伴应该知道，一篇笔记可以同时被不同文章引用，而trilium的克隆功能与之类似但又不仅于此。</p><p>从上一张截图可以看到，我的笔记右侧有一个<code>*</code>号，这代表这篇笔记被克隆了，即它成为了其他节点的子节点。这几个节点都是我在阅读《自卑与超越》一书时的读书笔记，所以我在整理归纳的时候就可以将这些笔记克隆到我的读书笔记下方。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101150511.png"></p><p>这样子我们就获得了一个拥有丰富上下文信息的知识碎片，在【笔记路径】选项中可以看到该笔记有多少处克隆的路径。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101223141.png"></p><p>忘了说，上文中的读书笔记是【知识仓库】的其中一个子节点，【知识仓库】是我用于整理归档的节点。可在此节点下进行分类，比如读书、健康、软件、操作系统……然后在子节点继续进行分类，比如在【操作系统】后建立windows、linux、mac os等节点……只要你想，就可以无限分类下去。一个知识点经常会有不同的分类，仅仅使用链接不能够很好的进行分类归纳，如果创建多个相同的笔记又显得杂乱臃肿，克隆这一功能的存在便很好的解决上述的问题。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101151323.png"></p><h2 id="知识输出"><a href="#知识输出" class="headerlink" title="知识输出"></a>知识输出</h2><p>按照以上两个流程进行一段时间后，会发现自己的知识仓库里拥有了很多没有整理的知识碎片，我们不需要有太多压力，只需要进行浏览，你就会惊讶的发现,啊原来这里已经有这么多的知识点了。</p><p>比如我今天写下的这篇博文，就是我在浏览【知识仓库】时发现，差不多好像可以形成一篇文章了，于是将之前的知识碎片重新进行整理，就形成了你们看见的这篇文章。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101152417.png"></p><p>同样，借用《卡片笔记法》的概念，此时写下的文章被称为【永久笔记】，在笔记库的根目录下建立【永久笔记】节点用于存放这类笔记。当然由于克隆的存在，你依然可以把他克隆到任意你觉得合适的地方。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101152636.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上便是我的日常工作流，我可以毫无压力的记下每日产生的灵感，并且由于日记的存在我可以很方便的回顾写下灵感时的上下文信息。随着时间的积累，你的知识仓库会变得越来越充实。当然，这种工作流使用大部分双链笔记都可以做到，但让我如此顺心的却是独一个。</p><h1 id="值得一提的特点"><a href="#值得一提的特点" class="headerlink" title="值得一提的特点"></a>值得一提的特点</h1><p>trilium丰富的功能也是我最终决定使用他的理由。</p><h2 id="基于数据库的存储"><a href="#基于数据库的存储" class="headerlink" title="基于数据库的存储"></a>基于数据库的存储</h2><p>曾经我一度认为md格式才是最好的笔记存储方式，md格式的好处有以下几点：</p><ol><li>文档掌握在自己手里</li><li>通用的格式，方便笔记迁移和博客发布</li><li>方便进行版本管理</li></ol><p>但后来我发现这并不是适合我的。一是因为我有多终端同步需求，git的版本管理毫无意义，而且容易产生冲突文件，二是由于obsidian与logseq等软件对markdown格式的魔改，反而使文件迁移变得更加困难！</p><p>而数据库本身就是为了解决纯文本存储带来的种种麻烦而出现的技术，trilium的数据库存储有以下几个优点：</p><ol><li>备份和还原方便</li><li>数据掌握在自己手里</li><li>更加方便的版本管理</li><li>可依托与数据库实现各种功能（trilium开放数据库接口，可以自己写js代码实现你想要的功能）</li></ol><h2 id="可部署服务端，实现多端同步"><a href="#可部署服务端，实现多端同步" class="headerlink" title="可部署服务端，实现多端同步"></a>可部署服务端，实现多端同步</h2><p>trilium可以部署在云服务器上，可通过web端和客户端进行访问，同步速度取决于你的服务器，不过由于它是增量同步，所以同步速度非常快。</p><p>自己部署服务端之后的同步体验，在目前所有开源或半开源的笔记系统中比较下来都是十分优秀的，上一次让我觉得这么舒心的同步方式还是私有部署的为知笔记。</p><h2 id="功能丰富的编辑器"><a href="#功能丰富的编辑器" class="headerlink" title="功能丰富的编辑器"></a>功能丰富的编辑器</h2><p>trilium的编辑器是基于开源编辑器：CKEditor 5，这是一款好用的富文本编辑器。虽然是富文本编辑器但是trilium能够把富文本笔记导出为markdown格式，而且转换出的格式十分规范。</p><p>除了富文本编辑功能之外，还支持许多格式的笔记，你甚至可以直接在笔记中调试和运行js代码。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101162458.png"></p><p>当然，markdown格式也是支持的，由于博文中需要添加Front-matte信息，所以平时记录时我会使用富文本编辑，但是写永久笔记的时候我会直接写markdown。trilium实现了基本的markdown颜色渲染，对于我而言也够用了，如果有需求的话trilium也支持用外部程序打开进行编辑，比如typaro、marktext等软件。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101163007.png"></p><p>除最基本的文本笔记之外，还支持画布笔记，渲染笔记，各种流程图、时序图等，功能不可谓不强大。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>trilium的属性类似于其他笔记软件的标签，而且除用户自定义标签之外，trilium还提供了一些自带的标签功能，比如，使用<code>#archived</code>标签可以将笔记归档。</p><p>此前使用obsidian时，如何处理归档文件令我十分头疼，存放在同一个库里时，总是出现在我的搜索结果和引用链接中，所以我只能建立一个新的库专门用于存放归档笔记，但这又令笔记的同步和管理出现问题。而在trilium中，归档的文件不会出现在搜索和引用中。</p><p>由于trilium的属性是可以设置为继承的，将其设置为继承后其下所有节点都会拥有继承的属性。所以我直接在根目录建立一个【归档】节点，打上可继承的archived标签，此后所有暂时不需要的笔记我全部存放进这个文件夹中。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101165150.png"></p><p>值得一提的是，如果在【归档】节点下放置某篇笔记的克隆，那么这篇笔记的其他所有克隆位置都会被归档。所以我更推荐的做法是在【归档】节点下建立要归档的笔记的克隆而不是直接将笔记拖进去，这样的好处是不会破坏知识仓库的结构。</p><p>此外，用户也可以自定义标签，定义的标签可以通过搜索查找、也可以通过sql语句查找还可以通过trilium的api查找，如果你有余力的话可以自己写js代码，实现各种功能，比如示例库中的体重记录就是通过获取“体重”标签实现的。</p><h2 id="笔记加密"><a href="#笔记加密" class="headerlink" title="笔记加密"></a>笔记加密</h2><p>设置为保护笔记之后，这篇笔记包括笔记名都会被加密，只有输入密码解密后才可访问。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101192948.png"></p><p>其实这只是一个最基础的功能，大部分传统的笔记软件都可以进行笔记加密，但习惯了开源和自己掌控笔记数据之后，这一功能在obsidian之类的软件之中也显得尤为珍贵。</p><h2 id="分享笔记"><a href="#分享笔记" class="headerlink" title="分享笔记"></a>分享笔记</h2><p>这是部署服务端后可使用的功能，点击分享按钮，即可生成一条公网链接分享你的笔记。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101195722.png"></p><h2 id="方便的笔记导入和导出"><a href="#方便的笔记导入和导出" class="headerlink" title="方便的笔记导入和导出"></a>方便的笔记导入和导出</h2><p>trilium的笔记导入十分方便，只需要将笔记打包成zip，即可一键导入，不过我遇到一个问题，不管是在linux还是windows下，导入zip的时候中文中文标题都会乱码，最后是通过bandizip在打包时选择使用AES256加密算法后才解决问题。</p><p>导出也十分方便，有多种导出选择，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221101200554.png"></p><h2 id="极强的拓展性"><a href="#极强的拓展性" class="headerlink" title="极强的拓展性"></a>极强的拓展性</h2><p>trilium本身的功能就已足够强大，但是其本质上是一个强大的”浏览器“，而且作者开放了笔记api，所以你完全可以将其打造成一个足够适合你的笔记软件。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>目前对于我来说，trilium是一款足够优秀的笔记软件，最重要的是它能让我沉下心来做好知识沉淀。</p><p>如果你还没有找到最适合的你的笔记软件，不妨试一试trilium。</p>]]></content>
    
    
    <categories>
      
      <category>好软推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记软件</tag>
      
      <tag>开源工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 开机挂载磁盘和swap分区</title>
    <link href="/2022/10/10/linux%20%E5%BC%80%E6%9C%BA%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98%E5%92%8Cswap%E5%88%86%E5%8C%BA/"/>
    <url>/2022/10/10/linux%20%E5%BC%80%E6%9C%BA%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98%E5%92%8Cswap%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近manjaro经常内存爆满，16G的物理内存理应来说是够的，但是不知道为什么有时候某个软件会突然占用过高的内存，后来发现是没有启用swap分区，但不知能否解决内存溢出的问题，先记下启用swap分区的方法。 Linux 中的 Swap 交换分区就是 Windows 中的虚拟内存，将Linux系统服务器中的物理硬盘空间虚拟化成内存使用，以解决内存不够的问题。不同的Linux【CentOS&#x2F;Ubuntu&#x2F;Debian】发行版新建，增加 Swap 分区的方法是一样的，下面致臻数据就分享下如何确定和创建 Swap 分区及大小。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="swap分区需要的大小"><a href="#swap分区需要的大小" class="headerlink" title="swap分区需要的大小"></a>swap分区需要的大小</h3><ol><li>&lt;&#x3D; 4g 至少 4G</li><li>4~16G 至少 8G</li><li>16G~64G 至少 16G</li><li>64G~256G 至少 32G</li></ol><h3 id="创建swap分区"><a href="#创建swap分区" class="headerlink" title="创建swap分区"></a>创建swap分区</h3><p>创建命令如下，其中 &#x2F;var&#x2F;swapfile 是文件位置，bs*count 是文件大下，比如我创建一个 16G 的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">dd if=/dev/zero of=/var/swapfile bs=4M count=4096<br></code></pre></td></tr></table></figure><h3 id="建立swap文件系统"><a href="#建立swap文件系统" class="headerlink" title="建立swap文件系统"></a>建立swap文件系统</h3><p>将文件格式化为swap分区文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">mkswap /var/swapfile<br></code></pre></td></tr></table></figure><h3 id="启用swap分区"><a href="#启用swap分区" class="headerlink" title="启用swap分区"></a>启用swap分区</h3><p>启用分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">swapon /var/swapfile<br></code></pre></td></tr></table></figure><p>查看是否成功启用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">free -m<br></code></pre></td></tr></table></figure><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><p>编辑<code>/etc/fstab</code>文件，在文件末尾加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">/var/swapfile swap swap defaults 0 0<br></code></pre></td></tr></table></figure><p>注意：中间用tab分割</p><h3 id="修改swappiness参数"><a href="#修改swappiness参数" class="headerlink" title="修改swappiness参数"></a>修改swappiness参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">vim /proc/sys/vm/swappiness<br></code></pre></td></tr></table></figure><p>内容的值来确定系统对 SWAP 分区的使用原则。当 swappiness 内容的值为 0 时，表示最大限度地使用物理内存，物理内存使用完毕后，才会使用 SWAP 分区。当 swappiness 内容的值为 100 时，表示积极地使用 SWAP 分区，并且把内存中的数据及时地置换到 SWAP 分区。 查看修改前为 0，需要在物理内存使用完毕后才会使用 SWAP 分区。 可以使用下述方法临时修改此参数，假设我们配置为空闲内存少于 15% 时才使用 SWAP 分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">echo 15 &gt;/proc/sys/vm/swappiness<br></code></pre></td></tr></table></figure><p>若需要永久修改此配置，在系统重启之后也生效的话，可以修改 <code>/etc/sysctl.conf</code> 文件，并增加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">vm.swappiness=15<br></code></pre></td></tr></table></figure><h3 id="挂载机械硬盘"><a href="#挂载机械硬盘" class="headerlink" title="挂载机械硬盘"></a>挂载机械硬盘</h3><p>也是编辑<code>/etc/fstab</code>文件 在末尾加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">/dev/sda1 /data ntfs defaults 0 0<br></code></pre></td></tr></table></figure><p>配置完成后可用<code>sudo mount -a</code>检查是否配置成功</p><h3 id="为某个用户挂载"><a href="#为某个用户挂载" class="headerlink" title="为某个用户挂载"></a>为某个用户挂载</h3><p>加入uid和gid参数，查看当前用户的uid的指令为<code>id</code></p><h3 id="挂载smb磁盘"><a href="#挂载smb磁盘" class="headerlink" title="挂载smb磁盘"></a>挂载smb磁盘</h3><p>替换成共享地址的路径，类型使用“cifs”，并且在参数项加入<code>username=,password=,iocharset=utf8</code></p><h2 id="etc-fstab详解"><a href="#etc-fstab详解" class="headerlink" title="etc/fstab详解"></a><code>etc/fstab</code>详解</h2><h4 id="文件作用"><a href="#文件作用" class="headerlink" title="文件作用"></a>文件作用</h4><p>磁盘被手动挂载之后都必须把挂载信息写入&#x2F;etc&#x2F;fstab这个文件中，否则下次开机启动时仍然需要重新挂载。  系统开机时会主动读取&#x2F;etc&#x2F;fstab文件中的内容，根据文件这个里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。  </p><h4 id="挂载的限制"><a href="#挂载的限制" class="headerlink" title="挂载的限制"></a>挂载的限制</h4><ol><li>根目录是必须挂载的，而且一定要先于其他mount point被挂载。因为mount是所有目录的跟目录，其他木有都是由根目录 &#x2F;衍生出来的。</li><li>挂载点必须是已经存在的目录。</li><li>挂载点的指定可以任意，但必须遵守必要的系统目录架构原则</li><li>所有挂载点在同一时间只能被挂载一次</li><li>所有分区在同一时间只能挂在一次</li><li>若进行卸载，必须将工作目录退出挂载点（及其子目录）之外。</li></ol><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>label或uid 用唯一名称定位需要挂载的分区或磁盘</p><p>挂载点 需要挂载到哪个目录下</p><p>磁盘的系统</p><p>文件系统的参数</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Async&#x2F;sync</td><td>设置是否为同步方式运行，默认为 async</td></tr><tr><td>auto&#x2F;noauto</td><td>当下载 mount -a 的命令时，此文件系统是否被主动挂载。默认为 auto</td></tr><tr><td>rw&#x2F;ro</td><td>是否以以只读或者读写模式挂载</td></tr><tr><td>exec&#x2F;noexec</td><td>限制此文件系统内是否能够进行 “执行” 的操作</td></tr><tr><td>user&#x2F;nouser</td><td>是否允许用户使用 mount 命令挂载</td></tr><tr><td>suid&#x2F;nosuid</td><td>是否允许 SUID 的存在</td></tr><tr><td>Usrquota</td><td>启动文件系统支持磁盘配额模式</td></tr><tr><td>Grpquota</td><td>启动文件系统对群组磁盘配额模式的支持</td></tr><tr><td>Defaults</td><td>同事具有 rw,suid,dev,exec,auto,nouser,async 等默认参数的设置</td></tr></tbody></table><p>dump 是否使用dump备份，0表示不需要，1表示每天，2表示不定日期，备份我一般使用其他方式，所以填0就好</p><p>是否检验 0表示不需要，1表示最早（一般根目录需要），2表示1级别完成之后进行检验</p>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小区路口的理发师-其二</title>
    <link href="/2022/09/30/%E5%B0%8F%E5%8C%BA%E8%B7%AF%E5%8F%A3%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88-%E5%85%B6%E4%BA%8C/"/>
    <url>/2022/09/30/%E5%B0%8F%E5%8C%BA%E8%B7%AF%E5%8F%A3%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88-%E5%85%B6%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>明天国庆小长假，可我并不期待。</p><p>可以说所有的假期我都并不是很期待，一是自己并不是一个爱热闹的人，不喜出门；二是假期容易打破自己规律的生活。</p><p>不过国庆嘛，终归是有些朋友要聚一聚的，想来头发有些日子没有打理了，于是打算今日前往小区路口的理发店修剪一下头发。</p><p>趁着还未完全暗下的暮光，我抓紧时间来到小区路口。还未踏进门我便听到隐约一股有规律的节奏声与人声交织在一起。</p><p>推开门后声音进一步放大。</p><p>只见理发师手里正拿着一只话筒沉浸在自己的世界里，稍许时间过去，我轻咳一声：“老板，理发。”</p><p>他终于注意到我，将手里的话筒放在新置办的茶几上，关掉音响，有些不好意思的招呼我：“先来洗个头吧。”</p><p>同往常一样，我并未与他进行过多交流，我只是静静坐着，他也只是默默给我理发。</p><p>每次进他的理发店都会发觉一些不同，上次来发现店里的墙上多了几副相框，里面是他和妻子的合照；这次来的时候他又置办了<br>K歌设备，以作没有客人时的消遣。</p><p>由此想来这间理发店应该与我第一次进来时已经大不相同。</p><p>理发师可能只是心里想着：或许这面墙上挂几张照片不错！或许没有生意的时候唱唱歌不错！</p><p>他这么想，也这么做了。</p><p>于是这间小小的理发店也随着他的生活轨迹慢慢改变，每一寸空间里都洋溢着他对生活的热爱。</p><p>理完发后我踏出店门，一如既往的，理发师的声音从身后传来，“路上慢点啊。”</p><p>夜色渐沉，我在回去的路上踱步，明天就是大家都期待的国庆小长假，可是我却不知为何有些怅然若失。</p>]]></content>
    
    
    <categories>
      
      <category>生活随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>身边小事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小区路口的理发师-其一</title>
    <link href="/2022/06/29/%E5%B0%8F%E5%8C%BA%E8%B7%AF%E5%8F%A3%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88-%E5%85%B6%E4%B8%80/"/>
    <url>/2022/06/29/%E5%B0%8F%E5%8C%BA%E8%B7%AF%E5%8F%A3%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88-%E5%85%B6%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>我的小区路口有一家理发店，理发的价格是15元一次。自从在县城理发付了70元的学费后我便成为这家理发店的常客。</p><p>这间理发店十分简陋，门口总是摆放着一辆黑色的敞篷小三轮，大概是他的交通工具，走进理发店，大约20平米的空间只简单摆放了几件沾满时光气息的家具以及一些理发工具。仔细闻闻，空气中还夹带着几丝腐败的难闻气息。</p><p>店主是一位约莫30来岁的细瘦男子，留着一头微卷的中分。每当我踏进门，他都会停下手里的工作，甩甩头发笑着说，“稍微坐一会儿哦，我这个很快就好。”</p><p>我一向不喜欢和理发师多沟通，只想安安静静的坐着，等待理发师剪好头发，然后离开。然而大部分理发师总喜欢和你闲聊几句，有些会和你聊聊工作八卦之类的家常，离谱的直接给你推荐几套会员卡套餐。</p><p>但是这个理发师却很安静，每次理发只是简单招呼我先过去洗个头，然后问我想怎么打理头发，接着便默默地开始他的工作。随着次数增多，话语更是精简到只剩开局的一句“和往常一样吗？”。</p><p>深得我心。</p><p>我曾经以为他就是这么一个不善言辞的人，直到有一次前去理发，听见他和座椅上的大妈闲聊地有来有回，我这才知道，原来他并非不善言辞，只不过是在照顾不同顾客的习惯罢了。</p><p>由此看来我其实和这个理发师并没有什么过多的交集，我不曾和他深入交流过，只不过偶尔从他和客人之间的谈话中听得一些事。</p><p>听闻他30多岁一直没有女朋友，后来在亲戚介绍下与一个离异带孩的女子草草结了婚。</p><p>他是这么说的，</p><p>“我也已经老大不小了，自己的条件不怎么样也不能对别人要求太高。何况这个女子人也不错，也是该有个家了。”</p><p>此处所说的女子我也见过几次，是一个身体有些发福的中年女人。有时她会抱着孩子坐在一旁的破旧沙发上，望着怀中酣睡的小孩，轻轻摇晃臂弯。眉眼之间尽是温柔。</p><p>上周，我在县城的街上与他偶遇，他坐在小三轮上停靠在路边，我走向前和他打招呼。</p><p>“呦！我也是xx小区的，去你那儿理过几次头发。你在这儿干嘛呢？”</p><p>他见着我，先是愣了一会儿，然后开心地说，“哦……哦！我带小孩子打针，老婆在上厕所，我在等她。”</p><p>我看向他的怀中，即使在吵闹的街区，孩子依然睡的十分安稳。</p><p>简单寒喧几句过后我说自己要走了，他像是巧遇故友却又要分别一样，热情地同我道别。</p><p>我不曾了解他的生活，不过我记得当时离开的路上，心情甚好。</p>]]></content>
    
    
    <categories>
      
      <category>生活随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>身边小事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哑</title>
    <link href="/2022/06/11/%E3%80%8A%E4%BB%A5%E5%A4%AA%E3%80%8B/"/>
    <url>/2022/06/11/%E3%80%8A%E4%BB%A5%E5%A4%AA%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="读《以太》有感"><a href="#读《以太》有感" class="headerlink" title="读《以太》有感"></a>读《以太》有感</h2><p>以下是本书对”以太”描写的原文：</p><blockquote><p>国会秘密通过第33条宪法修正案成立联邦信息安全委员会，对可能危害社会稳定和国家安全的信息进行过滤和替换，在漫长的尝试后，一套高效率的系统逐渐形成，这个系统叫作“以太”。最初，“以太”是工作在互联网上、对互联网设备和移动互联网设备进行监控的自动化体系，它对一切被认定存在潜在威胁的文字、视频、音频进行数据欺骗。简单举例，语义分析接口认定一个讨论组中的有害主题，“以太”对接入该讨论组所在服务器的所有相关会话发送欺骗信息，除发表者之外，其他人看到的都是经过调制的讨论话题，同时，信息发送者被数据库记录。假如你发表名为“参议员的午餐”的话题，被判定为有害信息，运行于巨型计算机上的、因法律体系而凌驾于所有网络防火墙之上的“以太”将在其他程序会话接入之前控制所有端口，将数据包中的相关字节替换，于是在别人眼里，你发表的话题就变成了无趣的“KFC超值午餐”。</p></blockquote><blockquote><p>随着“以太”的成功，联邦政府对广播、电视和纸质出版物的控制是顺理成章的结局，与“以太”同源的信息欺骗技术被用于隔离异见者，比如部分不肯认同信息安全法案的媒体人士。纳米微电子技术被用于信息欺骗，很快，掌权者意识到纳米机械在肉眼可见光范围内信息替换的潜力，第33条修正案颁布后的第七年，他们决定向空气中散播纳米微机械。这种微型设备悬浮在空气中，利用土壤和建筑材料中的硅进行自我复制，直至达到预定浓度，它们仅具有简单的机械结构，浓度达到规定程度后进入工作状态；它们会自动侦测具有潜在威胁的文字（可见光信号）和声音（音波信号），将其替换为无害信息，并将发布者记录在案。它们附着在印刷文本和标语牌表面，通过光偏振向除发布者之外的观察者发布欺骗光学信号；它们改变声波扩散形态，向除发布者之外的倾听者发布欺骗声学信号，当然，发布者本身因为骨骼的传导作用，听到的还是自己原本想说的话。飘浮在空气中的小恶魔使“以太”无所不能、无所不在，如同哲学家口中人类无法察觉却充满一切空间的神秘物质——“以太”本身。</p></blockquote><p>简单来说就是未来社会你在网络上发表的讨论，在现实里说的话，都被时刻监控着，并且被替换成“正确”的文字。就好像现在的论坛，你打的一些字被自动替换为：** 或者 口 等乱码，似乎就像是“以太”的雏形。不过在未来社会，这种现象会进一步加剧，连人与人之间的对话也在被以太监控着，我的耳朵永远不会听到肮脏的词汇，听不到阴谋论，世界开始变得美好…吗？</p><p>书中的主人公便是存在于这样的社会，世界被谎言包裹着，但是由于以太的隐秘性，主角根本不知道以太系统的存在，只是在过去的某一时刻突然发现世界变的无聊透顶。</p><blockquote><p>“有种东西在死去。”我左右望望，低声说，“你嗅不到腐烂的味道吗？电视节目里的评论员、报纸专栏作家、网络聊天组，自由的精神正在死去，像暴露在DDT中的蚊虫一样大规模死去。”</p></blockquote><p>世界失去了自由的声音，虽然所有人都在说着不同的话语，但好像说的都是一样的东西。在这样的世界里，主角感到麻木，一次机缘巧合下，主角加入了“手指聊天聚会”—一个通过手指交流的聚会。在这个被以太控制的世界，人们丧失话语权的世界，唯有用手指在彼此的手心写下精炼的短语才可以表达自己的真实想法。通过手指，我们可以讨论政治、讨论丑闻、表达任何思想，当然前提是掌握手指沟通的“语法”。</p><p>很滑稽却又很真实，我们拥有发声器官却没有办法“说话”，手指成了自由意志者最珍贵的礼物。</p><p>我查了下，这本科幻短篇发表于2013年，那还是一个比现在自由的多的时代，作者夸张的写出未来科技高度发展情况下，民众的言语被管控下的生活。现在看起来确实很夸张，可是又真实的让我背后发凉。不过这种事情一定发生在美国，我们大可不必担心。</p><p>其实想说的有很多，但是我却没办法说，或许我们已经被“以太”控制了。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将sheet批量保存为单独表格</title>
    <link href="/2022/06/09/%E5%B0%86sheet%E6%89%B9%E9%87%8F%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%8D%95%E7%8B%AC%E8%A1%A8%E6%A0%BC/"/>
    <url>/2022/06/09/%E5%B0%86sheet%E6%89%B9%E9%87%8F%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%8D%95%E7%8B%AC%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">Sub</span> ExportSheets()<br>    <span class="hljs-keyword">Dim</span> wsh <span class="hljs-keyword">As</span> Worksheet<br>    <span class="hljs-keyword">Dim</span> strPath <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    strPath = ThisWorkbook.Path &amp; <span class="hljs-string">&quot;\&quot;</span><br>    <span class="hljs-keyword">For</span> <span class="hljs-keyword">Each</span> wsh <span class="hljs-keyword">In</span> ActiveWindow.SelectedSheets<br>        wsh.Copy<br>        <span class="hljs-keyword">With</span> ActiveWorkbook<br>            .SaveAs strPath &amp; wsh.Name &amp; <span class="hljs-string">&quot;.xlsx&quot;</span>, FileFormat:=xlOpenXMLWorkbook<br>            .Close<br>        <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br>    <span class="hljs-keyword">Next</span> wsh<br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用ffmpeg推送RTMP流</title>
    <link href="/2022/05/19/%E4%BD%BF%E7%94%A8ffmpeg%E6%8E%A8%E9%80%81RTMP%E6%B5%81/"/>
    <url>/2022/05/19/%E4%BD%BF%E7%94%A8ffmpeg%E6%8E%A8%E9%80%81RTMP%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单位最近好像有网络直播的需要，说起网络直播，最常见的就是通过RTMP协议进行网络推流。 ffmpeg是一款开源的图像处理项目，可以方便的进行图像视频处理，推送操作，当然我们需要的推送RTMP流功能也可以很好的实现。 本文就以ffmpeg为工具进行RTMP的推送。</p><h2 id="安装ffmpeg"><a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装ffmpeg</h2><ol><li>在官网下载ffmpeg压缩包：<a href="http://ffmpeg.org/download.html">下载链接</a></li><li>解压到本地磁盘</li><li>将解压后的bin文件夹路径配置到系统环境变量中</li><li>打开cmd输入<code>ffmpeg –version</code>，可以看到ffmpeg的相关信息即可</li></ol><h2 id="配置RTMP服务器"><a href="#配置RTMP服务器" class="headerlink" title="配置RTMP服务器"></a>配置RTMP服务器</h2><ol><li>安装nginx，<a href="http://nginx.org/">下载地址</a></li><li>下载nginx-rtmp，<a href="https://github.com/illuspas/nginx-rtmp-win32">下载地址</a>下载后解压放到与nginx的同级目录</li><li>复制nginx的conf文件夹中的nginx-win.conf文件，在其末尾添加</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">rtmp &#123;<br>    server &#123;<br>        listen 1935;#监听端口,若被占用,可以更改<br>        chunk_size 4000;#上传flv文件块儿的大小<br>        application live &#123; #创建一个叫live的应用<br>             live on;#开启live的应用<br>             allow publish 127.0.0.1;#<br>             allow play all;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>以下代码可以实现将本地的视频以RTMP流的方式推送到RTMP服务器，实现网络直播。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">import cv2<br>import subprocess<br><br> camera_path = r&quot;本地视频地址&quot;<br><br> # 视频读取对象<br> cap = cv2.VideoCapture(camera_path) <br><br> # 读取一帧<br> ret, frame = cap.read()<br><br> # 推流地址<br> rtmp = &quot;RTMP服务器地址&quot;<br><br> fps = int(cap.get(cv2.CAP_PROP_FPS))<br> width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))<br> height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))<br> # 推流参数<br> command = [&#x27;D:\\ffmpeg\\bin\\ffmpeg.exe&#x27;,<br>    &#x27;-y&#x27;,<br>    &#x27;-f&#x27;, &#x27;rawvideo&#x27;,<br>    &#x27;-vcodec&#x27;,&#x27;rawvideo&#x27;,<br>    &#x27;-pix_fmt&#x27;, &#x27;bgr24&#x27;,<br>    &#x27;-s&#x27;, &quot;&#123;&#125;x&#123;&#125;&quot;.format(width, height),<br>    &#x27;-r&#x27;, str(fps),<br>    &#x27;-i&#x27;, &#x27;-&#x27;,<br>    &#x27;-c:v&#x27;, &#x27;libx264&#x27;,<br>    &#x27;-pix_fmt&#x27;, &#x27;yuv420p&#x27;,<br>    &#x27;-preset&#x27;, &#x27;ultrafast&#x27;,<br>    &#x27;-f&#x27;, &#x27;flv&#x27;, <br>    rtmp]<br><br> # 创建、管理子进程<br> pipe = subprocess.Popen(command, stdin=subprocess.PIPE)<br> size = (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), <br> int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))<br><br> # 循环读取<br> while cap.isOpened():<br>    # 读取一帧<br>    ret, frame = cap.read()<br>    if frame is None:<br>    print(&#x27;read frame err!&#x27;)<br>    continue<br>    <br>    # 显示一帧<br>    cv2.imshow(&quot;frame&quot;, frame)<br>    <br>    # 按键退出<br>    if cv2.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;):<br>    break<br><br>    # 读取尺寸、推流<br>    img=cv2.resize(frame,size)<br>    pipe.stdin.write(img.tobytes()) <br><br> cv2.destroyAllWindows()<br><br> cap.release()<br></code></pre></td></tr></table></figure><p>启动程序后，使用VLC或者Potplayer等软件读取RTMP地址即可播放。</p><h2 id="ffmpeg-python包"><a href="#ffmpeg-python包" class="headerlink" title="ffmpeg-python包"></a>ffmpeg-python包</h2><p>通过以上代码确实能够实现ffmpeg的推流，不过实际上只是调用了ffmpeg自带的命令行工具，更改参数什么的不太方便，后来了解到python有ffmpeg的包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">pip install ffmpeg-python<br></code></pre></td></tr></table></figure><p>关于ffmpeg包的使用，下次再另写一篇文章。</p>]]></content>
    
    
    <categories>
      
      <category>技术知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小工具</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总有人会在未来等你</title>
    <link href="/2022/05/07/%E3%80%8A%E9%95%9C%E4%B9%8B%E5%AD%A4%E5%9F%8E%E3%80%8B/"/>
    <url>/2022/05/07/%E3%80%8A%E9%95%9C%E4%B9%8B%E5%AD%A4%E5%9F%8E%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="读《镜之孤城》有感。"><a href="#读《镜之孤城》有感。" class="headerlink" title="读《镜之孤城》有感。"></a>读《镜之孤城》有感。</h2><p>之前从来没有想到我会因为看书而落泪，直到今天合上了这本书。</p><p>本书讲述的是七个因为各种原因想去学校而去不了的初中生，因为走进一面神奇的发着彩虹光芒的镜子进入一座城堡，需要寻找可以实现任何愿望的钥匙而产生的故事。<br>故事以安息心的视角展开，她是一个受到校园霸凌的孩子，所以对学校充满着恐惧，选择了逃避，不去上学，以及在她的视角下，了解到了其他6个孩子也是因为各种原因无法去学校上课。作为故事的主视角，作者对小心（校园霸凌受害者）的心理描写尤为出彩，令人共鸣。</p><blockquote><p>小心真正想要的是别人能告诉她，他至今为止并没有做错。</p></blockquote><p>明明什么都没有做错，为什么那些人要来欺负自己，为什么只欺负我，是不是我真的做错了什么，都怪我不好，做了惹他们不开心的事情…明明是受害者，但是却总是小心翼翼，甚至自己也产生了受害者有罪论的想法。那些校园暴力的施暴者，是心智不成熟吗，还是单纯的恶？而且为什么其他人好像只是当一个旁观者，没有人告诉我，我没有做错呢？明明错的是他们呀，只是一个很简单的道理，为什么当时没人说出来呢？</p><p>不是校园暴力的亲历者，真的很难体会到施暴者的无理程度。在城堡中，小心等7个孩子需要寻找“祈愿的钥匙”，用这个钥匙打开“祈愿的房间”能够实现一个任何愿望。小心内心许下的愿望是：</p><blockquote><p>要真田美织（施暴者）从这个世界上消失</p></blockquote><p>这是一个很可怕的愿望，但是却是唯一能够救赎小心的愿望。在十几岁的年纪里，对于世界的认识或许只停留在这个校园里，面对校园暴力时的无力感，老师、同学、家长，谁也帮不了自己。本该是属于这个年纪的美丽晴空，却在施暴者的折磨下，染成了看不到阳光的阴天。或许能做的只有在心里默默祈祷，出现奇迹，让施暴者消失吧。这是每一个校园暴力受害者最简单最恶毒的愿望了。</p><p>作为学生最亲近的老师，本该是作为理解和鼓励的一方，却只是简单处理了事，认为小心和美织他们只是在吵架。</p><blockquote><p>想不到老师是居然是这么轻飘飘的说法。一股强烈的反感，使他心中升起的怒气在脑子里沸腾了一般，意识到变得模糊了。<br>那可不是什么吵架呀！<br>吵架是互相语言能够相通的人才会进行的呀，属于更加对等的事情。</p></blockquote><p>学生的霸凌行为，在老师眼中估计只是小孩子玩闹吧，说实在的老师对于大部分人来说也只不过是一份谋生的职业罢了，再亲近的人都可能无法对彼此的遭遇感同身受，何况只是老师呢。所以大部分霸凌事件中，我们似乎都看不到老师的身影，你求助了老师，老师也不过是口头教育一下，加之采取叫家长等手段，似乎以为事情就此结束了，过段时间便抛之脑后。而那些霸凌者呢，则丝毫不会减轻自己的恶行。而那些受害者呢，在心中也留下了无法消失的伤疤。</p><p>只有小晶在听完小心对于自身经历的诉说后，温柔的说了这些：</p><blockquote><p>“了不起！”小晶说。<br>两个人的目光合在了一起后，小晶的眼睛直视着小心，温柔而又珍惜地说：<br>“了不起，你很坚强！”</p></blockquote><p>“你很坚强”，能够在承受了如此多的不公后依然坚持过来，你很坚强。简短的四个字在此刻却比什么都更有力量。陷入孤寂黑夜的孩子，最需要的就是一句温暖的肯定。不是以怜悯的眼光，不是以听故事的心态，而是听完之后的一句肯定，因为，我根本什么都没有做错呀。人们总是善于隐藏，将最痛最严重的伤疤藏在最深处。当揭开一层一层伪装后，渴望听到的，也仅仅是一句肯定和鼓励而已呀。</p><p>不止小心，其他6个孩子同样也承受着注入撒谎被指责、被同学孤立、被父母不抱期待、被继父性骚扰等挫折。每一个孩子都对现实恐惧着，所以选择进入城堡逃避现实，他们在城堡中只是在消磨时间，对于“祈愿的钥匙”也不是很看重，只是希望逃避罢了。</p><p>几乎每一天都有人在城堡里聊天、打游戏、或者什么都不做，只是呆在这儿。他们惊奇的发现原来他们都是同一所学校里不去上学的孩子，但又发现他们在现实中无法相见，因为他们似乎处于各自的平行世界中。</p><p>时间在城堡中一天天过去，快要到城堡关闭的时间了。</p><p>可是在关闭前的最后一天，小晶因为对现实绝望，一心寻死，所以没有在五点前回到现实。而根据城堡的规则，五点前没有回去的孩子会被狼吃掉，包括今天所有来过城堡的孩子，都会一起被吃掉。今天只有小心没有来过城堡，所以小心在今天必须拯救大家，这些给予他温暖的朋友们。</p><p>在过程中，小心读取了他们的记忆，知道了原来他们确实是来自同一个世界的，只不过来自不同时间。</p><blockquote><p>昴生活在 1985 年<br>小晶生活在 1992 年<br>小心和理音生活在 2006 年<br>政宗生活在 2013 年<br>风歌生活在 2020 年<br>嬉野生活在2027年</p></blockquote><p>最后小心找到了祈愿的钥匙，许下愿望：</p><blockquote><p>希望小晶回来，希望违反规则的事情没有发生过</p></blockquote><p>愿望实现了，发出一道光，小心拼命向光中的小晶呼喊：</p><blockquote><p>我们都在同一个世界！要勇敢起来，成长为大人，我在未来等你！</p></blockquote><p>曾经小晶温柔的拥抱小心柔弱的地方，现在轮到小心救赎小晶了。</p><p>之后，大家都回到了现实，关于城堡和这里发生的一切记忆都被消除了。可是大家的生活好像都发生了一些变化，有好像什么都没有变，仿佛一开始就是那样。</p><p>回到现实后，小晶被心里不知道哪里传出来的声音所鼓励，在好好的长大，和喜欢的人结婚了，改名喜多岛晶，并且创建了“心的教室”，帮助那些因为一些原因而不去学校的孩子。原来小晶就是在现实中一直温柔的帮助和鼓励小心的喜多岛老师。</p><p>我们从来都不是孤身一人，总有人会在未来等你，所以你要勇敢的长大。</p><p>所幸，我也好好的长大了。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死了三次的女孩</title>
    <link href="/2022/04/24/%E3%80%8A%E6%A1%B6%E5%B7%9D%E8%B7%9F%E8%B8%AA%E7%8B%82%E6%9D%80%E4%BA%BA%E4%BA%8B%E4%BB%B6%E3%80%8B/"/>
    <url>/2022/04/24/%E3%80%8A%E6%A1%B6%E5%B7%9D%E8%B7%9F%E8%B8%AA%E7%8B%82%E6%9D%80%E4%BA%BA%E4%BA%8B%E4%BB%B6%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="读《桶川跟踪狂杀人事件》有感"><a href="#读《桶川跟踪狂杀人事件》有感" class="headerlink" title="读《桶川跟踪狂杀人事件》有感"></a>读《桶川跟踪狂杀人事件》有感</h2><p>一个女孩被杀了三次，一次是警察，一次是凶手，一次是媒体。<br>作为保护人民的警察，在诗织三番五次的报案下，竟然毫无作为，不接受受理，用各种理由让诗织打消念头。甚至在诗织和家人的努力，不断提供证据好不容易受理之后，跑到诗织家里让诗织撤销报案，这是多么令人绝望的一件事。假如警方早一点提高警惕，早点行动，诗织或许就不会死了。正是警方的不作为和渎职，在命案发生前就杀死了诗织。</p><blockquote><p>“我完全可以理解那天诗织和父母来这里求助之后，如何陷入了绝望。这里病入膏肓。这里没有半个“人”。诗织遭遇了两个不幸。一个是认识了小松，另一个就是住在上尾署的辖区里。”</p></blockquote><p>这里没有半个“人”，这里都是披着人皮的怪物。书中的警察是简直毫无作为，对报案者的生死毫不关心，总是推诿搪塞，根本不配他们身上的那套警服。世界上有多少人已经失去了职业道德，只是把工作当成按时打卡领工资的流水线，对什么都漠不关心，在乎的只是工资高低，年终奖多少。我承认，这是不可避免的，在这个时代，没有人愿意做没有利益的事情，曾经庄重的誓言也能成为虚伪的代名词。在这个时代我们只能祈祷自己不会成为下一个绝望的诗织。</p><p>作者对无良媒体的描写，放到现在也不过时。对受害者外貌的详细刻画：迷你裙、厚底长靴、高级手表、名牌背包…媒体很“客观”的描述了受害者的特征，他们似乎什么都没说，但也什么都说了。刻意对受害者的形象进行描写，让大众产生联想：</p><blockquote><p>穿这么短的裙子，是想勾引谁？<br>戴名牌手表，和那个男人在一起不就是为了钱吗？<br>迷恋名牌，就是一个爱玩，招摇的女孩，难怪会遇上这种男人<br>…</p></blockquote><p>警方片面透露的信息加上媒体片面描写的报道，让诗织又被杀害了一次，在媒体的片面刻画下，作为死者的尊严也丧失了。被害者有害论，这直到20多年后的今天依然存在。各种利刃不断地往受害者身上甩去，现在的网民和诗织案的读者如出一辙，在媒体的片面报道下，对受害者指指点点，在受害者的身上找出被害原因，最终心满意足的打下一行字：就是因为你这样啊，才被害的，不要这样不就好了吗。按下回车键，一柄利刃无情的发送了出去。<br>当然，媒体是左右舆论的重要力量，有时候媒体所谓的客观性其实只是片面的客观罢了，比如一件事有两面性，我只报道了其中一面，你能说是我表达的不客观吗。而且大部分时候，民众也只是被动接收信息，不会花费时间探求事件全貌。</p><blockquote><p>“是因为媒体报道，所以民众关注，还是因为民众关注，媒体才大肆报道？”</p></blockquote><p>如今话语权已经成为这个世界最重要的权利之一。而掌握话语权的媒体，特别是官方媒体，一句话就可以改变社会舆论风向。一篇片面的报道，一则博眼球的新闻就能左右着人们的想法。或许民众是因为看了某篇报道才关注，亦或是因为民众自发的对某件事关注，媒体才下场，这其实无所谓，重要的是媒体在其中扮演一个怎样的角色，是一个客观的记录者，还是主观的引导者，我不知道。</p><p>作者清水洁，作为一个周刊记者，正义和愤怒驱使着他对诗织被害案件持续的追踪。周刊是三流媒体的代名词，以夸张的标题著称，很多新闻资源都是周刊记者得不到的。清水洁也是一个普通的媒体人员，他也会动摇，也会在不暴露嫌疑人和周刊临近截稿之间作斗争，但是当他逐渐深入案件，看到了警方的无能，看到了其他媒体博眼球的报道，以及聆听诗织朋友、家人的倾述之后无形中被托付的那什么，他承担起了自己本不用承担的责任。<br>豆瓣中看到一句话：“人都是复杂的，如果简单把凶手认定为恶魔，等于直接宣布这是小概率随机事件，消解了可能的改变和预防的空间。我们谁都不会觉得自己会碰见恶魔，但事实上，亲密关系中的暴力是极为普遍的。简单粗暴的标签化反而会更多地苛责受害者，加诸新的伤害。”<br>确实，很多人对凶手的印象仍然停留在面目狰狞，心灵扭曲的形象之中。但是现实案件里，加害者往往是熟人作案、亲密关系作案或者冲动作案，甚至可能是我们走在路上擦肩而过的任何人。人性是很复杂的，没有人是单纯的天使，也没有人是单纯的恶魔，每个人的心中都有善的一面和恶的一面，世界上没有完美加害人。就连本案的凶手小松也不例外，小松对诗织的行为，被称为恶魔行径也不为过，但是在另一个女生的描述中，小松也有脆弱、温柔的一面。<br>这是一起让人心碎的案件，读完之后有深深的无力感，我们每个人都有可能成为下一个诗织，但不能保证每次都有一个清水洁寻找真相。<br>诗织是不幸的，也是幸运的，但是那只暗沉无奇，戴了好多年的所谓名牌手表，在那一天，这只表上的指针永远指向了十二点五十分。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双拼的尝试</title>
    <link href="/2022/04/13/%E5%8F%8C%E6%8B%BC%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
    <url>/2022/04/13/%E5%8F%8C%E6%8B%BC%E7%9A%84%E5%B0%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>因为时代的原因，我使用的打字方式一直是PC全拼加手机九宫格的打字习惯。这两种打字方式已经很习惯了，但是打字效率以及正确率方面还是有所不足。首先是PC自然码全拼，我虽然能做到手比脑更快，以及利用缩写和组词提高打字效率，但是其时大部分是利用了如今输入法的智能词云罢了，而且遇到生僻词，翻页找词就需要好久，尤其是对我这种平翘舌、前后鼻音不分的人来说使用起来就更不方便了。手机九宫格就更不用说了，词组重复率太高了。<br>于是今天尝试一下双拼，其实一直听说过双拼的大名，也被人推荐过，但每次都因为不愿意付出学习成本而浅尝辄止。毕竟要放弃自己使用了这么久的打字习惯，何必呢？学习双拼还得重新记住键盘的键位，看看这毫无逻辑的键位，实在是让人望而却步。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030182552.png"><br>要是搁我以前，我看一眼就放弃了，但是今天硬着头皮摸索了一番，并且在<a href="https://api.ihint.me/shuang/">双拼练习 @ BlueSky (ihint.me)</a>个网站上练习了一会儿，摸清楚了打字方法后，把手机和电脑的输入法全换成了小鹤双拼。<br>WINDOWS自带输入法并没有小鹤双拼的方案，需要进行如下设置：</p><blockquote><ol><li>win+R 输入 regedit，打开注册表</li><li>找到 HKEY_CURRENT_USER\Software\Microsoft\InputMethod\Settings\CHS</li><li>新建一个字符串文件</li><li>名称为：<code>UserDefinedDoublePinyinScheme0</code></li><li>值为：<code>小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt</code></li></ol></blockquote><p>本文全程使用小鹤双拼打字，刚开始学习，实在是太折磨了，打着打着就想用全拼打字，脑袋和手不协调的感觉真是让人感觉心里有蚂蚁在爬，但是通过不断的使用和纠错，目前已经不需要借助键位图了。但是打字效率还是远远不及全拼打字，目前这个状态让我想起小学第一次接触电脑，在金山打字上玩“警察抓小偷”的时候，使用的“小鸡啄米打字法”。</p><p>不过目前的学习进度，我还是很满意的，应该过不了多久就就能熟练掌握了。</p>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>输入法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置多用户共享磁盘</title>
    <link href="/2022/03/25/%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%94%A8%E6%88%B7%E5%85%B1%E4%BA%AB%E7%A3%81%E7%9B%98/"/>
    <url>/2022/03/25/%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%94%A8%E6%88%B7%E5%85%B1%E4%BA%AB%E7%A3%81%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ol><li>每个人都有一个单独的文件夹，每个文件夹单独配置账户</li><li>授权用户可查看自己的文件夹和公用文件夹，不可访问其他用户的文件夹</li><li>在其他机子上能临时性的快速访问自己的文件夹</li></ol><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>通过windows自带的smb共享协议，其他电脑可以轻松的通过资源管理器访问服务器上的文件，而且通过在服务器上为每个文件夹分配账户权限，可以实现多用户配置。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>单位有100来号人，一个一个手动创建实在是太麻烦了，于是用python调用cmd指令进行批量操作。<br>主要流程如下：</p><ol><li>创建系统用户，包括姓名、部门、默认密码</li><li>为每个用户在服务器磁盘上创建单独的文件夹</li><li>在文件夹上配置共享，并设置对应的权限</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> xlrd<br><br>path = <span class="hljs-string">&#x27;F:\\服务器文件\\用户资料库&#x27;</span><br>book_path = path+<span class="hljs-string">&quot;\\name.xls&quot;</span><br>book = xlrd.open_workbook(book_path)<br>sheet = book.sheets()[<span class="hljs-number">0</span>]<br><br>rows = sheet.nrows<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,rows):<br>    username = sheet.cell_value(i,<span class="hljs-number">0</span>)<br>    group = sheet.cell_value(i,<span class="hljs-number">1</span>)<br>    password = <span class="hljs-string">&quot;123456&quot;</span><br><br>    <span class="hljs-comment"># 创建用户并设置密码及禁止修改密码</span><br>    command = <span class="hljs-string">&quot;net user %s %s /passwordchg:no /expires:never /FULLNAME:%s /add&quot;</span> %(username, password, username)<br>    os.system(command)<br> <br>    <span class="hljs-comment"># 设置密码永不过期</span><br>    command = <span class="hljs-string">&quot;wmic useraccount where \&quot;name=&#x27;%s&#x27;\&quot; set passwordexpires=false&quot;</span>%(username)<br>    os.system(command)<br>     <br>    <span class="hljs-comment"># 设置属组</span><br>    command = <span class="hljs-string">&quot;net localgroup %s %s /add&quot;</span> %(group, username)<br>    os.system(command)<br> <br>    <span class="hljs-comment"># 删除默认Users组</span><br>    command = <span class="hljs-string">&quot;net localgroup Users %s /del&quot;</span> %(username)<br>    os.system(command)<br><br>    <span class="hljs-comment"># 创建文件夹</span><br>    userpath = path+<span class="hljs-string">&quot;\\&quot;</span>+username<br>    os.mkdir(userpath,<span class="hljs-number">777</span>)<br><br>    <span class="hljs-comment"># 配置安全权限</span><br>    command = <span class="hljs-string">&quot;Cacls %s /t /e /c /g %s:F&quot;</span>%(userpath,username)<br>    os.system(command)<br><br>    <span class="hljs-comment"># 配置共享权限</span><br>    command = <span class="hljs-string">&quot;net share %s=%s /GRANT:%s,FULL&quot;</span>%(username,userpath,username)<br>    os.system(command)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小工具</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我们都是无期徒刑</title>
    <link href="/2022/03/16/%E3%80%8A%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E3%80%8B/"/>
    <url>/2022/03/16/%E3%80%8A%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="读《消失的13级台阶》有感"><a href="#读《消失的13级台阶》有感" class="headerlink" title="读《消失的13级台阶》有感"></a>读《消失的13级台阶》有感</h2><blockquote><p>我们都是无期徒刑，没有必要假释。</p></blockquote><p>这是一本看完后，会产生许多思考的小说。书中多次探讨死刑的合理性和犯罪之后的悔过态度。</p><p>死刑是最严重的一种刑罚，中国有句话说，一命偿一命，虽然不适用于现在的社会，但是死刑仍然是惩罚犯重罪的犯人的最终刑罚。</p><p>死刑能限制人的恶吗？罗翔老师说过，刑法是对人的最低的道德要求。当一个人触犯了法律，会有对应的惩罚等着他。就像是台阶，一阶一阶的数落着你的罪恶。但是死刑于其他惩罚完全不一样，死刑与人权挂钩，很难用标准来评判死刑是否正确，连一直坚持死刑正确的南乡，在经历了这些事件后也逐步变得无法确定了。例如书中所说的死刑和无期徒刑，可能犯人只是在认错态度上有区别，但是一边是生的希望，一边是却死的绝望。</p><p>正如书中探讨的，司法审判究竟是一种惩罚还是还是改造。如果是作为惩罚，那么对犯罪者施以最严重的惩罚，甚至死刑，让人们知道犯了罪就是要付出代价的，可是世界上还会有这么多的犯罪呢？是缺少对死亡的敬畏吗，所以肆意剥夺他人的生命。或许直到他们踏上死刑台，才会产生畏惧吧。</p><p>不过随着社会的演变，刑法逐渐向如何改造罪犯的角度转变，越来越多的国家废止死刑也可证明这一点。司法审判时可以根据犯罪人的悔过态度酌情减轻刑罚，在日本甚至还有恩赦制度。在监狱，犯人表现良好甚至可以获得减刑和假释。在这个制度下，书中有真心悔过，好好生活的室户英彦，但也有再次杀人的安藤纪夫。或许现有的刑罚制度只能从客观角度对犯人实行惩罚，犯人是否真的会怀有悔过之心回归社会，也没有其他人能够评判。</p><p>纯一为了保护女友，对强奸犯心怀杀意，本是蓄意谋杀，但是却阴差阳错的变为故意伤害，只被判了两年，并且纯一最终坦诚，自己毫无悔过之心。南乡根本没有触犯刑法，但是手握三条人命，却始终陷入无期徒刑的自我审判中。而树原亮根本没有犯罪，却时时刻刻被不知什么时候就会踏上死刑台的恐惧所折磨。</p><p>刑法是件很难带主观情绪去思考的东西，有些人是迫不得已被逼上了犯罪的道路，当你处在相同的境地下，或许也会做出相同的选择，每个人的心中都有恶的成分，就像纯一，当你的幸福被无情的剥夺，法律却无法保护你的时候，就会打开心中的开关，释放出对他人的恶意。我们不知道自己内心的开关会在什么时候打开，或许我们都得怀着心中潜藏的恶意，判处无期徒刑。 </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sharp DX-2058NC的折腾记录</title>
    <link href="/2022/03/04/Sharp%20DX-2058NC%E7%9A%84%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/03/04/Sharp%20DX-2058NC%E7%9A%84%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天正好有扫描文件的需要，而办公室里的扫描仪只能扫描A4纸大小的文件，所以有很多局限性。而单位有一台Sharp DX-2508NC打印机，可以满足大纸张的扫描需要，但是据其他同事说，扫描功能坏了，不能用了。但我想着这玩意儿应该没这么容易坏吧，于是折腾了两天，绕了许多弯路，最终解决问题。</p><h1 id="折腾记录"><a href="#折腾记录" class="headerlink" title="折腾记录"></a>折腾记录</h1><h2 id="一、怀疑是扫描软件的问题"><a href="#一、怀疑是扫描软件的问题" class="headerlink" title="一、怀疑是扫描软件的问题"></a>一、怀疑是扫描软件的问题</h2><p>这台打印机具有扫描功能，所以很自然的想到，既然已经安装了打印机的驱动，打印正常，那么扫描应该也能用吧。<br>于是打开Acrobat，选择从扫描仪创建PDF，但是很遗憾找不到Sharp的扫描仪。<br>以为是扫描软件的问题，于是下载了其他扫描软件，皆失败。</p><h2 id="二、怀疑是驱动不完整"><a href="#二、怀疑是驱动不完整" class="headerlink" title="二、怀疑是驱动不完整"></a>二、怀疑是驱动不完整</h2><p>或许是我只安装了打印模块，没有安装扫描模块？我这么想。于是上夏普官网，找到SharpDX-2508型号，一看，<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030191038.png"></p><p>DX-2508NC只有一种打印驱动，但是看到下面兄弟型号2008UC有一款TWAIN扫描驱动程序，想着兄弟型号的扫描驱动说不定也能用。<br>下载安装后，测试失败。</p><h2 id="三、怀疑是后台配置出错"><a href="#三、怀疑是后台配置出错" class="headerlink" title="三、怀疑是后台配置出错"></a>三、怀疑是后台配置出错</h2><p>后来发现该设备具有网络扫描功能，于是登陆该设备后台，发现，其他同事已经尝试过了，不死心的我继续尝试。在后台中可看见有四种图像发送方式<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030191123.png"></p><h3 id="1-测试E-mail发送"><a href="#1-测试E-mail发送" class="headerlink" title="1.测试E-mail发送"></a>1.测试E-mail发送</h3><p>首先需要配置SMTP，在网络设置中，配置好使用的SMTP服务器，这里我用的是网易的服务器，配置好后连接测试通过。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030191157.png"></p><p>之后在后台像其他邮箱发送测试页也成功。</p><p>于是上机测试，在打印机的图像发送界面中选择发送的邮箱地址，点击发送，显示“寻找网络服务器失败”，邮箱中未收到扫描文件。</p><h3 id="2-测试共享文件夹"><a href="#2-测试共享文件夹" class="headerlink" title="2.测试共享文件夹"></a>2.测试共享文件夹</h3><p>在局域网内的办公电脑上，创建了一个共享文件夹，将该地址填入打印机后台的地址簿中，配置如下:<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030191236.png"><br>经过测试其他电脑确实可以访问我的共享文件夹，但是在打印机上选择该地址后，依然无法发送扫描文件。<br>怀疑是把文件夹路径写错了，于是依次测试了“192.168.1.205”、“192.168.1.205&#x2F;打印共享”、“192.168.1.205\打印共享”，皆失败。</p><h3 id="3-其他方式"><a href="#3-其他方式" class="headerlink" title="3.其他方式"></a>3.其他方式</h3><p>之后测试了FTP、桌面等方式，也都不行。</p><h2 id="四、找到解决办法"><a href="#四、找到解决办法" class="headerlink" title="四、找到解决办法"></a>四、找到解决办法</h2><p>在夏普官网的服务支持的下载专区中（就是之前下载驱动的地方）有个被我忽略的东西<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20220324202543.png"></p><p>我下载了试试，发现这正是夏普官方的扫描软件。<br>按照文件中的流程将sharpdesk下载并安装好，打开软件，我发现扫描居然如此简单。</p><ol><li><p>打开软件，点击【工具】-【产品配置】-【网络扫描工具】</p></li><li><p>添加扫描仪<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030191321.png"></p></li><li><p>然后新建一个地址，用于保存扫描文件。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030191346.png"></p></li></ol><p>之后再打印机上选择我们刚才建立的地址，点击发送即可成功将扫描文件传输到我们设置的文件夹中。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>正确的配置流程其实很简单，问题就在于不知道哪条道路是正确的，仅凭借以往的经验也很容易碰壁。所以还是需要多思考，验证各种可能性。</p>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>打印机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信任</title>
    <link href="/2022/03/02/%E3%80%8A%E6%80%92%E3%80%8B/"/>
    <url>/2022/03/02/%E3%80%8A%E6%80%92%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="读《怒》有感。"><a href="#读《怒》有感。" class="headerlink" title="读《怒》有感。"></a>读《怒》有感。</h2><p>说来挺有意思的，这本书我本来是当推理小说看的，但是越看越不对劲，书里写了三个故事线，讲述了三个故事中的主人公遇见了一个来历不明的男人之后发生的故事。一点都没提到开头的凶杀案，我一度以为自己可能看了什么盗版。<br>于是上豆瓣瞅了一眼评论，我很其实讨厌被剧透，所以只是简单瞄一眼书友看完此书的感受，大概就是“前半段很无聊，后半段很感人”、“戳中泪点”、“立意很深”之类的。说实话和我的预期有点不一样，我是当作推理小说看的，但是我偶然看到了一条评论：“……直人、田中、田代是同一个人……”。我只看到了这行字，因为害怕被剧透，不敢继续再看了，赶紧关了手机，心想：“这么刺激？”。顿时对这本小说产生了兴趣，并且后悔刚才为什么要看那条评论。<br>所以我一直在把三个故事中的男人当作凶手，分析他们行为的动机，梳理三个故事的时间线，认为三个故事是依次发生的。但是今天阅读到最后一页时，结局与我预想的差距太大，我感觉我好像成为了故事中的一员。</p><p>本书与其说是推理小说，不如说是社会小说，故事一开始就明确了犯罪嫌疑人是山神一也，全书也是围绕在爱子和田代，优树和直人，景、辰哉和田中，以及警察追踪凶手这四条线进行叙述，凶手是三个男人中的一个——田中，但是其他似乎与凶杀案毫无关系的人们，他们的生活也因此发生了巨大的变化。</p><p>田中的逃跑路线其实很明了，犯罪后辗转在工地，每次觉得身份要暴露的时候就辗转到其他地方，最后逃到了波留间岛，在这里隐姓埋名生活。遇到了景，遇到了辰哉，遇到了能接受他的人们，他们互相信任，景在那霸险些被强奸，田中和辰哉互相信守承诺，不会告诉别人在那霸发生的这件事。可是事实是什么，田中是一只披着人皮的怪物，他在星岛废墟的墙上，写下了这段恶俗的文字：</p><blockquote><p>“看到美国兵干一个女的，那女的我认识，好玩儿，有个老头喊了一句 Police 就结束了，别跑啊，美国兵儿干到最后啊，女的晕倒了，好玩儿”</p></blockquote><p>看到这一段文字，辰哉怒了，我也怒了。田中背叛了我们的信任，之前的态度完全是表演出来的，这段文字和墙上一个大大的“怒”字才是他的真实面孔。他或许是内心扭曲的反社会人格，或许是我们不能理解的精神变态，或许是有着悲惨过去的失败者，又或许仅仅是一个易怒的普通人……这些都随着辰哉把刀刺进田中胸口的那个晚上不得而知了。田中的心里是没有由来的“怒”，并且将怒气强加到别人身上，正如那场凶杀案，无缘无故便杀死了两个毫不相干的人。但是辰哉的“怒”却是由保护景这个念头产生的，直到最后，辰哉也没有把景在那霸的事情说出来，尽管这有可能为他减轻惩罚。<br>本书其实讲的是信任的故事，辰哉和景相互信任，但是田中却背叛了这份信任，正因为书中所说：“我是因为信任他，所以无法原谅他”，辰哉杀死田中不是因为他是杀人犯，而是因为他背叛了信任。<br>另外两个故事其实和杀人案并无关系，但是因为杀人案轰动全国，且凶手整过容，所以对身边符合条件的人产生了怀疑。书中讲述的便是其中的两件故事。<br>直人出生在悲惨人家，又因为是同性恋，所以过的很不顺利，但是遇到优树后，他觉得自己得到了救赎，终于不用在意周围人眼光，觉得自己也可以好好生活了，为了不打破这种关系，直人隐瞒了自己心脏有问题的事实。优树其实是希望信任直人的，他曾对自己说，跟怀疑的对象说“我怀疑你”，就等于跟对方说“我相信你”。但是优树没有把信任一直持续下去，怀疑直树是盗窃犯，是通缉犯。直树死亡的那一晚，面对警察的的电话询问，也无法说一句“我认识他”……对于亲近的人，我们不妨多给一些信任。<br>田代因为躲避从父亲那儿“继承”的巨额债务，之前也过着东奔西跑的生活，直到遇见了爱子和洋平，他甚至好好考虑和爱子他们生活在一起的可能性，也开始向往美好的生活。但是也是因为这没有由来的不信任，田代或许是因为过去被发现了，不想拖累他们，所以逃走了，后来也是因为信任爱子他们，所以选择回来共同面对。<br>本书的故事结构令人唏嘘，真正的凶手得到了周围人毫无保留的信任，其他两个清白的人却被亲近的人所怀疑。作者这种刻意营造的结构，令平淡的结局回味无穷。直到最后我们也不知道田中为何杀人，为何在墙上书写大大的“怒”字，优树也永远无法对直人说一句对不起，所幸田代和爱子有机会走向明天。<br>其实书中人物的怀疑并不为过，作者想说的也不仅仅是信任与否这么简单的东西，或许是在探讨怀疑和爱之间，什么更重要吧。<br>怀疑是一种本能，但是爱给与的信任却足以包容一切。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对文件的高阶操作-shutil库</title>
    <link href="/2022/01/24/%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E9%AB%98%E9%98%B6%E6%93%8D%E4%BD%9C-shutil%E5%BA%93/"/>
    <url>/2022/01/24/%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E9%AB%98%E9%98%B6%E6%93%8D%E4%BD%9C-shutil%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>shutil模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。</p><blockquote><p>即便是高阶文件拷贝函数 ([<code>shutil.copy()</code>], [<code>shutil.copy2()</code>]也无法拷贝所有的文件元数据。</p></blockquote><h1 id="文件夹与文件操作"><a href="#文件夹与文件操作" class="headerlink" title="文件夹与文件操作"></a>文件夹与文件操作</h1><h2 id="copyfileobj"><a href="#copyfileobj" class="headerlink" title="copyfileobj"></a>copyfileobj</h2><p>将fsrc文件内容复制至fdst文件，length为fsrc每次读取的长度，用做缓冲区大小</p><p>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">copyfileobj(fsrc, fdst, length=<span class="hljs-number">16</span>\*<span class="hljs-number">1024</span>)<br></code></pre></td></tr></table></figure><ul><li>fsrc： 源文件</li><li>fdst： 复制至fdst文件</li><li>length： 缓冲区大小，即fsrc每次读取的长度</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> shutil<br>f1 = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>)<br>f2 = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;file_copy.txt&quot;</span>,<span class="hljs-string">&quot;a+&quot;</span>)<br>shutil.copyfileobj(f1,f2,length=<span class="hljs-number">1024</span>)<br></code></pre></td></tr></table></figure><h2 id="copyfile"><a href="#copyfile" class="headerlink" title="copyfile"></a>copyfile</h2><p>将src文件内容复制至dst文件</p><p>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">copyfile(src, dst[,follow_symlinks])<br></code></pre></td></tr></table></figure><ul><li>src： 源文件路径</li><li>dst： 复制至dst文件，若dst文件不存在，将会生成一个dst文件；若存在将会被覆盖</li><li>follow_symlinks：设置为True时，若src为软连接，则当成文件复制；如果设置为False，复制软连接。默认为True。Python3新增参数</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> shutil<br><span class="hljs-title">shutil</span>.copyfile(<span class="hljs-string">&quot;file.txt&quot;</span>,<span class="hljs-string">&quot;file_copy.txt&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="copymode"><a href="#copymode" class="headerlink" title="copymode"></a>copymode</h2><p>将src文件权限复制至dst文件。文件内容，所有者和组不受影响</p><p>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">copymode(src, dst[,follow_symlinks])<br></code></pre></td></tr></table></figure><ul><li>src： 源文件路径</li><li>dst： 将权限复制至dst文件，dst路径必须是真实的路径，并且文件必须存在，否则将会报文件找不到错误</li><li>follow_symlinks：设置为False时，src, dst皆为软连接，可以复制软连接权限，如果设置为True，则当成普通文件复制权限。默认为True。Python3新增参数</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> shutil<br><span class="hljs-title">shutil</span>.copymode(<span class="hljs-string">&quot;file.txt&quot;</span>,<span class="hljs-string">&quot;file_copy.txt&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="copystat"><a href="#copystat" class="headerlink" title="copystat"></a>copystat</h2><p>将权限，上次访问时间，上次修改时间以及src的标志复制到dst。文件内容，所有者和组不受影响</p><p>完整语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">copystat(src, dst[,follow_symlinks])<br></code></pre></td></tr></table></figure><ul><li>src： 源文件路径</li><li>dst： 将权限复制至dst文件，dst路径必须是真实的路径，并且文件必须存在，否则将会报文件找不到错误</li><li>follow_symlinks：设置为False时，src, dst皆为软连接，可以复制软连接权限、上次访问时间，上次修改时间以及src的标志，如果设置为True，则当成普通文件复制权限。默认为True。Python3新增参数</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> shutil<br><span class="hljs-title">shutil</span>.copystat(<span class="hljs-string">&quot;file.txt&quot;</span>,<span class="hljs-string">&quot;file_copy.txt&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>将文件src复制至dst。dst可以是个目录，会在该目录下创建与src同名的文件，若该目录下存在同名文件，将会报错提示已经存在同名文件。权限会被一并复制。本质是先后调用了copyfile与copymode而已</p><p>完整语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">copy(src, dst[,follow_symlinks])<br></code></pre></td></tr></table></figure><ul><li>src：源文件路径</li><li>dst：复制至dst文件夹或文件</li><li>follow_symlinks：设置为False时，src, dst皆为软连接，可以复制软连接权限，如果设置为True，则当成普通文件复制权限。默认为True。Python3新增参数</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">improt shutil,<span class="hljs-built_in">os</span><br>shutil.copy(<span class="hljs-string">&quot;file.txt&quot;</span>,<span class="hljs-string">&quot;file_copy.txt&quot;</span>)<br># 或者<br>shutil.copy(<span class="hljs-string">&quot;file.txt&quot;</span>,<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.getcwd(),<span class="hljs-string">&quot;copy&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="copy2"><a href="#copy2" class="headerlink" title="copy2"></a>copy2</h2><p>将文件src复制至dst。dst可以是个目录，会在该目录下创建与src同名的文件，若该目录下存在同名文件，将会报错提示已经存在同名文件。权限、上次访问时间、上次修改时间和src的标志会一并复制至dst。本质是先后调用了copyfile与copystat方法而已</p><p>完整语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">copy2(src, dst[,follow_symlinks])<br></code></pre></td></tr></table></figure><ul><li>src：源文件路径</li><li>dst：复制至dst文件夹或文件</li><li>follow_symlinks：设置为False时，src, dst皆为软连接，可以复制软连接权限、上次访问时间，上次修改时间以及src的标志，如果设置为True，则当成普通文件复制权限。默认为True。Python3新增参数</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">improt shutil,<span class="hljs-built_in">os</span><br>shutil.copy2(<span class="hljs-string">&quot;file.txt&quot;</span>,<span class="hljs-string">&quot;file_copy.txt&quot;</span>)<br># 或者<br>shutil.copy2(<span class="hljs-string">&quot;file.txt&quot;</span>,<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.getcwd(),<span class="hljs-string">&quot;copy&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="ignore-patterns"><a href="#ignore-patterns" class="headerlink" title="ignore_patterns"></a>ignore_patterns</h2><p>忽略模式，用于配合<code>copytree()</code>方法，传递文件将会被忽略，不会被拷贝</p><p>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ignore_patterns(patterns)<br></code></pre></td></tr></table></figure><ul><li>patterns：文件名称，元组</li></ul><h2 id="copytree"><a href="#copytree" class="headerlink" title="copytree"></a>copytree</h2><p>拷贝文档树，将src文件夹里的所有内容拷贝至dst文件夹</p><p>完整语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">copytree(src,dst[,symlinks=<span class="hljs-literal">False</span>,ignore=<span class="hljs-literal">None</span>,copy_function=copy2,ignore_dangling_symlinks=false])<br></code></pre></td></tr></table></figure><ul><li>src：源文件夹</li><li>dst：复制至dst文件夹，该文件夹会自动创建，需保证此文件夹不存在，否则将报错</li><li>symlinks：是否复制软连接，True复制软连接，False不复制，软连接会被当成文件复制过来，默认False</li><li>ignore：忽略模式，可传入<code>ignore_patterns()</code></li><li>copy_function：拷贝文件的方式，可以传入一个可执行的处理函数，默认为copy2，Python3新增参数</li><li>ignore_dangling_symlinks：sysmlinks设置为False时，拷贝指向文件已删除的软连接时，将会报错，如果想消除这个异常，可以设置此值为True。默认为False,Python3新增参数</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">import shutil,<span class="hljs-built_in">os</span><br>folder1 = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.getcwd(),<span class="hljs-string">&quot;aaa&quot;</span>)<br># bbb与ccc文件夹都可以不存在,会自动创建<br>folder2 = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.getcwd(),<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-string">&quot;ccc&quot;</span>)<br># 将<span class="hljs-string">&quot;abc.txt&quot;</span>,<span class="hljs-string">&quot;bcd.txt&quot;</span>忽略，不复制<br>shutil.copytree(folder1,folder2,ignore=shutil.ignore_patterns(<span class="hljs-string">&quot;abc.txt&quot;</span>,<span class="hljs-string">&quot;bcd.txt&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="rmtree"><a href="#rmtree" class="headerlink" title="rmtree"></a>rmtree</h2><p>移除文档树，将文件夹目录删除</p><p>完整语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">rmtree(path, ignore_errors=<span class="hljs-literal">False</span>, onerror=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>ignore_errors：是否忽略错误，默认False</li><li>onerror：定义错误处理函数，需传递一个可执行的处理函数，该处理函数接收三个参数：函数、路径和excinfo</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">import shutil,<span class="hljs-built_in">os</span><br>folder1 = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.getcwd(),<span class="hljs-string">&quot;aaa&quot;</span>)<br>shutil.rmtree(folder1)<br></code></pre></td></tr></table></figure><h2 id="move"><a href="#move" class="headerlink" title="move"></a>move</h2><p>将src移动至dst目录下。若dst目录不存在，则效果等同于src改名为dst。若dst目录存在，将会把src文件夹的所有内容移动至该目录下面</p><p>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">move(src, dst[,copy_function])<br></code></pre></td></tr></table></figure><ul><li>src：源文件夹或文件</li><li>dst：移动至dst文件夹，或将文件改名为dst文件。如果src为文件夹，而dst为文件将会报错</li><li>copy_function：拷贝文件的方式，可以传入一个可执行的处理函数。默认为copy2，Python3新增参数</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> shutil,os<br># 示例一，将src文件夹移动至dst文件夹下面，如果bbb文件夹不存在，则变成了重命名操作<br>folder1 = os.path.<span class="hljs-keyword">join</span>(os.getcwd(),&quot;aaa&quot;)<br>folder2 = os.path.<span class="hljs-keyword">join</span>(os.getcwd(),&quot;bbb&quot;)<br>shutil.<span class="hljs-keyword">move</span>(folder1, folder2)<br># 示例二，将src文件移动至dst文件夹下面，如果bbb文件夹不存在，则变成了重命名操作<br>file1 = os.path.<span class="hljs-keyword">join</span>(os.getcwd(),&quot;aaa.txt&quot;)<br>folder2 = os.path.<span class="hljs-keyword">join</span>(os.getcwd(),&quot;bbb&quot;)<br>shutil.<span class="hljs-keyword">move</span>(file1, folder2)<br># 示例三，将src文件重命名为dst文件(dst文件存在，将会覆盖)<br>file1 = os.path.<span class="hljs-keyword">join</span>(os.getcwd(),&quot;aaa.txt&quot;)<br>file2 = os.path.<span class="hljs-keyword">join</span>(os.getcwd(),&quot;bbb.txt&quot;)<br>shutil.<span class="hljs-keyword">move</span>(file1, file2)<br></code></pre></td></tr></table></figure><h2 id="disk-usage"><a href="#disk-usage" class="headerlink" title="disk_usage"></a>disk_usage</h2><p>获取当前目录所在硬盘使用情况。Python3新增方法<br>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">disk_usage(path)<br></code></pre></td></tr></table></figure><ul><li>path：文件夹或文件路径。windows中必须是文件夹路径，在linux中可以是文件路径和文件夹路径</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import shutil.os<br>path = os.path.join(os.getcwd(),<span class="hljs-string">&quot;aaa&quot;</span>)<br><span class="hljs-built_in">info</span> = shutil.disk_usage(path)<br><span class="hljs-built_in">print</span>(info)   # usage(<span class="hljs-attribute">total</span>=95089164288, <span class="hljs-attribute">used</span>=7953104896, <span class="hljs-attribute">free</span>=87136059392)<br></code></pre></td></tr></table></figure><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>修改路径指向的文件或文件夹的所有者或分组。Python3新增方法</p><p>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">chown(path, user=<span class="hljs-literal">None</span>, group=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>path：路径</li><li>user：所有者，传递user的值必须是真实的，否则将报错no such user</li><li>group：分组，传递group的值必须是真实的，否则将报错no such group</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> shutil,os<br><span class="hljs-type">path</span> = os.path.<span class="hljs-keyword">join</span>(os.getcwd(),&quot;file.txt&quot;)<br>shutil.chown(<span class="hljs-type">path</span>,<span class="hljs-keyword">user</span>=&quot;root&quot;,<span class="hljs-keyword">group</span>=&quot;root&quot;)<br></code></pre></td></tr></table></figure><h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>获取给定的cmd命令的可执行文件的路径。Python3新增方法</p><p>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">which(cmd, mode=os.F_OK | os.X_OK, path=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> shutil<br>info = shutil.which(<span class="hljs-string">&quot;python3&quot;</span>)<br><span class="hljs-keyword">print</span>(info)   # <span class="hljs-regexp">/usr/</span>bin/python3<br></code></pre></td></tr></table></figure><h1 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h1><p>shutil还提供了创建和读取压缩和存档文件的高级使用程序。内部实现主要依靠的是zipfile和tarfile模块</p><h2 id="make-archive"><a href="#make-archive" class="headerlink" title="make_archive"></a>make_archive</h2><p>生成压缩文件</p><p>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">make_archive(base_name, <span class="hljs-built_in">format</span>, root\_<span class="hljs-built_in">dir</span>, …)<br></code></pre></td></tr></table></figure><ul><li>base_name：压缩文件的文件名，不允许有扩展名，因为会根据压缩格式生成相应的扩展名</li><li>format：压缩格式</li><li>root_dir：将制定文件夹进行压缩</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">import shutil,<span class="hljs-built_in">os</span><br>base_name = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.getcwd(),<span class="hljs-string">&quot;aaa&quot;</span>)<br><span class="hljs-built_in">format</span> = <span class="hljs-string">&quot;zip&quot;</span><br>root_dir = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.getcwd(),<span class="hljs-string">&quot;aaa&quot;</span>)<br># 将会root_dir文件夹下的内容进行压缩，生成一个aaa.zip文件<br>shutil.make_archive(base_name, <span class="hljs-built_in">format</span>, root_dir)<br></code></pre></td></tr></table></figure><h1 id="get-archive-formats"><a href="#get-archive-formats" class="headerlink" title="get_archive_formats()"></a>get_archive_formats()</h1><p>获取支持的压缩文件格式。目前支持的有：tar、zip、gztar、bztar。在Python3还多支持一种格式xztar</p><h1 id="unpack-archive"><a href="#unpack-archive" class="headerlink" title="unpack_archive"></a>unpack_archive</h1><p>解压操作。Python3新增方法</p><p>完整语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">unpack_archive(filename, extract_dir=<span class="hljs-literal">None</span>, <span class="hljs-built_in">format</span>=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>filename：文件路径</li><li>extract_dir：解压至的文件夹路径。文件夹可以不存在，会自动生成</li><li>format：解压格式，默认为None，会根据扩展名自动选择解压格式</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">import shutil,<span class="hljs-built_in">os</span><br>zip_path = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.getcwd(),<span class="hljs-string">&quot;aaa.zip&quot;</span>)<br>extract_dir = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.getcwd(),<span class="hljs-string">&quot;aaa&quot;</span>)<br>shutil.unpack_archive(zip_path, extract_dir)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
      <category>技术知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openwrt cloudflare的ddns插件安装</title>
    <link href="/2022/01/12/openwrt%20cloudflare%E7%9A%84ddns%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/2022/01/12/openwrt%20cloudflare%E7%9A%84ddns%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>先下载cloudflareddns插件，下载地址：<a href="https://wws.lanzouy.com/iJvl3ybr32h">https://wws.lanzouy.com/iJvl3ybr32h</a><br>然后使用winscp登录路由器，将插件上传到tmp路径下。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030190622.png"></p><p>接着使用xshell登录路由器，目录切换到tmp下，执行命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">opkg install ddns-scripts_cloudflare.com-v4_2<span class="hljs-number">.7</span><span class="hljs-number">.8</span>-13_<span class="hljs-built_in">all</span>.ipk<br></code></pre></td></tr></table></figure><p>等待安装完毕后，在网页上刷新路由器后台地址，打开动态dns插件，发现插件安装成功<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030190655.png"><br>下面进行配置</p><p>主要有以下几项配置：</p><ul><li>查询主机名 – 你的主机名，主要用于显示域名是否与ip绑定成功，例如 text.com</li><li>域名 – 填写一个子域名，例如<a href="mailto:&#x64;&#101;&#x40;&#x74;&#101;&#120;&#x74;&#x2e;&#99;&#x6f;&#109;">&#x64;&#101;&#x40;&#x74;&#101;&#120;&#x74;&#x2e;&#99;&#x6f;&#109;</a>，如果使用主域名则只需要填写@text.com即可</li><li>用户名 – cloudflare的登录名</li><li>密码 – cloudflare后台中的Global API Key</li></ul><p>配置正确的话会出现如下界面<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030190811.png"></p>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>路由器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown语法学习</title>
    <link href="/2021/12/13/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/12/13/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown语法学习"><a href="#markdown语法学习" class="headerlink" title="markdown语法学习"></a>markdown语法学习</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>使用 # 号可以表示1-6级标题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一级标题</span><br><span class="hljs-comment">## 二级标题</span><br><span class="hljs-comment">### 三级标题</span><br><span class="hljs-comment">#### 四级标题</span><br><span class="hljs-comment">##### 五级标题</span><br><span class="hljs-comment">###### 六级标题</span><br></code></pre></td></tr></table></figure><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>使用两个以上空格加回车可以换行</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">*斜体文本*<br>**粗体文本**<br>***粗斜体文本***<br></code></pre></td></tr></table></figure><p>效果如下</p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><em><strong>粗斜体文本</strong></em></p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>分隔线可以很随意，如下所示均可以创建分割线，但是在为知笔记里就只能使用下面的第三种方法</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Plain">*******<br> * * * <br>- - -<br>----------<br></code></pre></td></tr></table></figure><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>在文字两端加两个波浪线即可</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>可使用HTML标签实现，为知笔记不支持</p><p><u>xxx</u></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是对文本的补充说明，为知笔记暂不支持，作为代替可以使用评论功能</p><p>格式如下</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plain">我现在要使用脚注了[^脚注]<br>[^脚注]：这是一个脚注<br></code></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>以下符号均可创建无序列表</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Plain">*<br>-<br>+<br><br></code></pre></td></tr></table></figure><p>有序列表可以用数字加 . 来表示</p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>在次级列表前添加四个空格，为知笔记中可以简便的使用换行进行自动缩进</p><ol><li>第一项<ol><li>第二项</li></ol></li></ol><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>暂时不知道有什么用，但是在文章中提高阅读性有点用</p><p>在段落开头使用 &gt; 符号，后面跟一个空格</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plain">&gt; 区块内容<br>&gt; 区块内容<br></code></pre></td></tr></table></figure><blockquote><p>区块内容<br>区块内容</p></blockquote><p>此外，区块中还可以使用列表，列表中也可以使用区块</p><ol><li>第一项</li></ol><blockquote><p>区块</p></blockquote><h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><p>如果是段落中的一个代码片段，可以将其用一个 ` 包起来</p><p><code>print()</code>函数</p><p>若是一整段的代码，可以用三个 ` 包裹</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>可采用如下方式</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Plain">&lt;https://baidu.com&gt;<br>[百度](https://baidu.com)<br><br>在这里定义网址[google][google]<br>然后在文章末尾进行赋值<br>[google]: https://google.com<br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">![替代文字](图片地址)<br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Plain">|表头|表头|<br>|-----|-----|<br>| | |<br></code></pre></td></tr></table></figure><p>其中可以设置表格的对其方式</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Plain">| 左对齐 | 右对齐 | 居中对齐 |<br>| :-----| ----: | :----: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |<br></code></pre></td></tr></table></figure><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="支持HTML语言"><a href="#支持HTML语言" class="headerlink" title="支持HTML语言"></a>支持HTML语言</h3><p>可以使用HTMl语言渲染文本，但是这并非markdown标准语法范围之内，所以需要编辑器同样至此HTML渲染才可认出格式</p><p>如</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑<br></code></pre></td></tr></table></figure><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>使用 \ 进行转义，如下符号前均支持</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Plain">\   反斜线<br>`   反引号<br>*   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure><h3 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h3><p>在公式前使用$$符号即可</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>横向源码格式<br>更多语法：[[mermaid语法]]</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Plain">```mermaid<br>graph LR<br>A[方形] --&gt;B(圆角)<br>    B --&gt; C&#123;条件a&#125;<br>    C --&gt;|a=1| D[结果1]<br>    C --&gt;|a=2| E[结果2]<br>    F[横向流程图]<br></code></pre></td></tr></table></figure><p>竖向 换成graph TD</p><p>标准格式</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Plain">```flow<br>st=&gt;start: Start<br>op=&gt;operation: Your Operation<br>cond=&gt;condition: Yes or No?<br>e=&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Plain">定义元素的写法： tag=&gt;type: content:&gt;url<br><br>元素名对应的意思<br>start # 开始<br>end # 结束<br>operation # 操作<br>subroutine # 子程序<br>condition # 条件<br>inputoutput # 输入或产出<br>content就是在框框中要写的内容，注意type后的冒号与文本之间一定要有个空格。<br>url是一个连接，与框框中的文本相绑定<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Plain">```mermaid<br>graph TD<br>A[方形] --&gt; B(圆角)<br>    B --&gt; C&#123;条件a&#125;<br>    C --&gt; |a=1| D[结果1]<br>    C --&gt; |a=2| E[结果2]<br>    F[竖向流程图]<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 战斗开始<br>op=&gt;operation: 进行攻击<br>cond=&gt;condition: 是否暴击<br>e2=&gt;operation: 结束<br>e=&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;e2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解docker</title>
    <link href="/2021/12/12/%E4%BA%86%E8%A7%A3Docker/"/>
    <url>/2021/12/12/%E4%BA%86%E8%A7%A3Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h1><p>Docker 是 PaaS 提供商 dotCloud 开源的一个基于 LXC 的高级容器引擎，源代码托管在 Github 上, 基于go语言并遵从Apache2.0协议开源。<br>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。<br>Docker daemon 一般在宿主主机后台运行，等待接收来自客户端的消息。 Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker daemon 交互。<br>一句话简单概括：<br>docker相当于是一艘船，docker中的镜像相当于是一个个集装箱，每个集装箱之间互不干扰。</p><h1 id="docker使用中的术语"><a href="#docker使用中的术语" class="headerlink" title="docker使用中的术语"></a>docker使用中的术语</h1><ul><li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030181802.png"><br>术语解释</li></ul><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>Docker 镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td>Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td>Docker 客户端(Client)</td><td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td></tr><tr><td>Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td>Docker Registry</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。<br><br>Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。<br><br>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。<br><br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td></tr><tr><td>Docker Machine</td><td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table><h1 id="常用docker命令"><a href="#常用docker命令" class="headerlink" title="常用docker命令"></a>常用docker命令</h1><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><ul><li>-a stdin: 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-P: 随机端口映射，容器内部端口随机映射到主机的端口</li><li>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name&#x3D;”nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username&#x3D;”ritchie”: 设置环境变量；</li><li>–env-file&#x3D;[]: 从指定文件读入环境变量；</li><li>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net&#x3D;”bridge”: 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；</li><li>–link&#x3D;[]: 添加链接到另一个容器；</li><li>–expose&#x3D;[]: 开放一个端口或一组端口；</li><li>–volume , -v: 绑定一个卷</li></ul><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">docker rm [OPTIONS] CONTAINER [CONTAINER…]<br></code></pre></td></tr></table></figure><p>OPTIONS说明：</p><blockquote><p>-f:  通过 SIGKILL 信号强制删除一个运行中的容器。<br>-i: 移除容器间的网络连接，而非容器本身。<br>-v 删除与容器关联的卷。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nas</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian笔记同步方案</title>
    <link href="/2021/11/23/obsidian%E7%AC%94%E8%AE%B0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/"/>
    <url>/2021/11/23/obsidian%E7%AC%94%E8%AE%B0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>obsidian是一款基于本地文件的笔记软件，所以笔记的多端同步是个问题，虽然官方推出了自己的同步服务，但是本着能自己解决就自己解决的态度，我自己研究出了一个比较完美的同步方案。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>因为我用的是苹果手机，所以自然而然的考虑到了icloud同步这个方法。<br>在手机版obsidian上创建笔记库，在windows上下载icloud，登录icloud账号，obsidian选择在icloud中打开笔记文件。<br>经过如上操作之后就解决了同步问题，本篇完（并没有） ^8fe52d</p><p>起初我是通过这种方案，但是使用一段时间后发现，在写笔记的过程中，obsidian经常弹出“文件被外部修改，正在合并”的提示，然后再icloud中就会出现若干个重复笔记。<br>类似这样：<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030191512.png"></p><p>而且写着写着经常会有几行笔记消失了。<br>所以以上几宗罪使icloud同步变得很难用。</p><h1 id="真·解决方案"><a href="#真·解决方案" class="headerlink" title="真·解决方案"></a>真·解决方案</h1><h2 id="自动同步icloud和本地"><a href="#自动同步icloud和本地" class="headerlink" title="自动同步icloud和本地"></a>自动同步icloud和本地</h2><p>为了解决上述问题，我写了一个自动同步的程序，使其每隔两分钟在本地文件和icloud中同步一次。<br>同步的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">file_cmp</span>(<span class="hljs-params">f1,f2</span>):<br>    res = filecmp.dircmp(f1,f2)<br>    common_dirs = res.common_dirs<br>    common_files = res.common_files<br>    same_files = res.same_files<br>    left_only = res.left_only<br>    right_only = res.right_only<br><br>    <span class="hljs-comment"># 只有目标地址有的文件则直接删除</span><br>    <span class="hljs-keyword">if</span> right_only != []:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(right_only)):<br>            _newpath = f2+<span class="hljs-string">&quot;\\&quot;</span>+right_only[i]<br>            <span class="hljs-keyword">if</span> os.path.isdir(_newpath):<br>                os.removedirs(_newpath)<br>            <span class="hljs-keyword">else</span>:<br>                os.remove(_newpath)<br><br><br>    <span class="hljs-comment"># 共有但有不同的文件进行拷贝</span><br>    <span class="hljs-keyword">if</span> common_files != []:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(common_files)):<br>            <span class="hljs-keyword">if</span> common_files[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> same_files:<br>                shutil.copy(f1+<span class="hljs-string">&quot;\\&quot;</span>+common_files[i],f2+<span class="hljs-string">&quot;\\&quot;</span>+common_files[i])<br><br>    <span class="hljs-comment"># 只有源地址有的文件和目录则直接拷贝</span><br>    <span class="hljs-keyword">if</span> left_only != []:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(left_only)):<br>            <span class="hljs-keyword">if</span> os.path.isdir(f1+<span class="hljs-string">&quot;\\&quot;</span>+left_only[i]):<br>                shutil.copytree(f1+<span class="hljs-string">&quot;\\&quot;</span>+left_only[i],f2+<span class="hljs-string">&quot;\\&quot;</span>+left_only[i])<br>            <span class="hljs-keyword">else</span>:<br>                shutil.copy(f1+<span class="hljs-string">&quot;\\&quot;</span>+left_only[i],f2+<span class="hljs-string">&quot;\\&quot;</span>+left_only[i])<br><br>    <br>    <span class="hljs-comment"># 有共同目录则递归比较子目录</span><br>    <span class="hljs-keyword">if</span> common_dirs != []:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(common_dirs)):<br>            file_cmp(f1+<span class="hljs-string">&quot;\\&quot;</span>+common_dirs[i],f2+<span class="hljs-string">&quot;\\&quot;</span>+common_dirs[i])<br></code></pre></td></tr></table></figure><p>然后我们建立一个while循环，持续运行这段代码，并且监测时间，当时间超过2分钟后进行一次备份。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">nowtime = time.time()<br>    oldtime = nowtime + backuptime*<span class="hljs-number">60</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        nowtime = time.time()<br>        <span class="hljs-keyword">if</span> nowtime &gt;= oldtime:<br>            file_cmp(filepath1,filepath2)<br>            oldtime += backuptime*<span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>文件同步就实现了，但是我的笔记是需要经常在不同的设备上打开的，所以在主程序中我们加入这么一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开软件时先从目标地址拉取最新版本</span><br> file_cmp(filepath2,filepath1)<br></code></pre></td></tr></table></figure><p>这样，当打开程序时，首先先拉取一次icloud上的笔记文件，之后就每隔2分钟向icloud中同步一次。</p><h2 id="让obsidian和我的程序同步启动和关闭"><a href="#让obsidian和我的程序同步启动和关闭" class="headerlink" title="让obsidian和我的程序同步启动和关闭"></a>让obsidian和我的程序同步启动和关闭</h2><h3 id="同步关闭"><a href="#同步关闭" class="headerlink" title="同步关闭"></a>同步关闭</h3><p>思路是要让obsidian和我的程序同步关闭，则需要持续监听obsidian进程是否存在，如果obsidian进程不存在，则自动关闭程序。<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 监听某个进程是否存在</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">checkprocess</span>(<span class="hljs-params">processname</span>):<br>    plist = psutil.pids() <br>    msgcode = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> pid <span class="hljs-keyword">in</span> plist:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> psutil.Process(pid).name() == processname:<br>                msgcode = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                msgcode = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">except</span> Exception:<br>            msgcode = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> msgcode<br></code></pre></td></tr></table></figure><p>以上代码是用于监听某个程序是否存在，接着我们写一个方法，让obsidian关闭之后，程序过140秒之后再结束，这样就有充足的时间备份到云端，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">delay</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> checkprocess(<span class="hljs-string">&quot;Obsidian.exe&quot;</span>) == <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 让程序延迟一会儿再执行，以便程序完成备份</span><br>            time.sleep(backuptime*<span class="hljs-number">70</span>)<br>            os._exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>然后在主函数中新建一个线程打开这个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">thread_it(delay)<br></code></pre></td></tr></table></figure><p>现在就实现了当Obsidian进程关闭时，就自动关闭程序</p><h3 id="同步启动"><a href="#同步启动" class="headerlink" title="同步启动"></a>同步启动</h3><p>我们将写好的程序打包成EXE，这里我是用pyinstaller作为打包工具<br>在命令行中输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pyinstaller -F -w comfile.py<br></code></pre></td></tr></table></figure><p>等待片刻，将dist中的exe文件拷到别的地方（方便你自己找到）。<br>假设你已经拷好了，在同一个目录下建立一个txt，名称和后缀改成：”obsidian.bat”，如下：<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20211220193725.png"><br>右键bat文件进行编辑，输入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">start <span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;obsidian的路径&quot;</span><br>start <span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;刚才的拷贝的exe的路径&quot;</span><br></code></pre></td></tr></table></figure><p>上面输入你自己的路径，保存。<br>接下来，还是在这个文件夹下的空白位置右键，新建一个快捷方式，在弹出的窗口中输入如下内容：<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030191540.png"></p><p>同样的，后面输入刚才创建的的bat文件路径，点击下一步。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20211220194453.png"><br>这里命名为obsidian.exe，点击完成，这时文件夹下就出现了一个“obsidian.exe”的快捷方式，为了更直观的操作，我们改一下他的图标，接着我们右键这个快捷方式，找到“更改图标”按钮，在弹出来的窗口中找到obsidian.exe的文件路径，点击确定。<br><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030191556.png"></p><p>到此，所有的操作完毕，你可以像其他快捷方式一样，将这个快捷方式拖到开始界面，任务栏或者桌面。并且，点击它会自动打开obsidian和文件同步程序，点开后，我们在任务管理里可以看到程序已经在运行了<br>当obsidian关闭时，该进程也会自动关闭，基本是无缝无感的操作体验。这样我的多端同步问题就解决了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇是基于icloud方式进行同步，其实icloud还可以替换为坚果云或者其他的云盘软件。<br>如果不想使用云盘软件，那么在本文的基础上，你也可以搭建基于webdav的同步方案，如果有需要的话我可以再出一期webdav的笔记同步方案。</p>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
      <category>好软推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小工具</tag>
      
      <tag>python</tag>
      
      <tag>笔记软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python subprocess库</title>
    <link href="/2021/11/13/python%20subprocess%E5%BA%93/"/>
    <url>/2021/11/13/python%20subprocess%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>subprocess这个模块来产生子进程,用于执行shell指令，并连接到子进程的标准输入&#x2F;输出&#x2F;错误中去，还可以得到子进程的返回值。<br>subprocess意在替代其他几个老的模块或者函数，比如：</p><ul><li>os.system os.spawn* </li><li>os.popen* </li><li>popen2.* </li><li>commands.*</li></ul><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/ll641058431/article/details/84930394">subprocess的用法_soman的博客</a></li><li><a href="https://www.cnblogs.com/-qing-/p/10934322.html#_labelTop">Python之subprocess模块 - 卿先生</a></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="常用subprocess方法"><a href="#常用subprocess方法" class="headerlink" title="常用subprocess方法"></a>常用subprocess方法</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>subprocess.run()</td><td>Python 3.5中新增的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例。</td></tr><tr><td>subprocess.call()</td><td>执行指定的命令，返回命令执行状态，其功能类似于os.system(cmd)。</td></tr><tr><td>subprocess.check_call()</td><td>Python 2.5中新增的函数。 执行指定的命令，如果执行成功则返回状态码，否则抛出异常。其功能等价于subprocess.run(…, check&#x3D;True)。</td></tr><tr><td>subprocess.check_output()</td><td>Python 2.7中新增的的函数。执行指定的命令，如果执行状态码为0则返回命令执行结果，否则抛出异常。</td></tr><tr><td>subprocess.getoutput(cmd)</td><td>接收字符串格式的命令，执行命令并返回执行结果，其功能类似于os.popen(cmd).read()和commands.getoutput(cmd)。</td></tr><tr><td>subprocess.getstatusoutput(cmd)</td><td>执行cmd命令，返回一个元组(命令执行状态, 命令执行结果输出)，其功能类似于commands.getstatusoutput()。</td></tr></tbody></table><h2 id="popen类"><a href="#popen类" class="headerlink" title="popen类"></a>popen类</h2><blockquote><p>popen的构造函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, args, bufsize=-<span class="hljs-number">1</span>, executable=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                 stdin=<span class="hljs-literal">None</span>, stdout=<span class="hljs-literal">None</span>, stderr=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                 preexec_fn=<span class="hljs-literal">None</span>, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,</span><br><span class="hljs-params">                 shell=<span class="hljs-literal">False</span>, cwd=<span class="hljs-literal">None</span>, env=<span class="hljs-literal">None</span>, universal_newlines=<span class="hljs-literal">False</span>,</span><br><span class="hljs-params">                 startupinfo=<span class="hljs-literal">None</span>, creationflags=<span class="hljs-number">0</span>,</span><br><span class="hljs-params">                 restore_signals=<span class="hljs-literal">True</span>, start_new_session=<span class="hljs-literal">False</span>,</span><br><span class="hljs-params">                 pass_fds=(<span class="hljs-params"></span>), *, encoding=<span class="hljs-literal">None</span>, errors=<span class="hljs-literal">None</span></span>)<br></code></pre></td></tr></table></figure><blockquote><p>参数说明</p></blockquote><ul><li>&#x3D;&#x3D;args&#x3D;&#x3D;： 要执行的shell命令，可以是字符串，也可以是命令各个参数组成的序列。当该参数的值是一个字符串时，该命令的解释过程是与平台相关的，因此通常建议将args参数作为一个序列传递。</li><li>&#x3D;&#x3D;bufsize&#x3D;&#x3D;： 指定缓存策略，0表示不缓冲，1表示行缓冲，其他大于1的数字表示缓冲区大小，负数 表示使用系统默认缓冲策略。</li><li>&#x3D;&#x3D;stdin&#x3D;&#x3D;, &#x3D;&#x3D;stdout&#x3D;&#x3D;, &#x3D;&#x3D;stderr&#x3D;&#x3D;： 分别表示程序标准输入、输出、错误句柄。</li><li>&#x3D;&#x3D;preexec_fn&#x3D;&#x3D;： 用于指定一个将在子进程运行之前被调用的可执行对象，只在Unix平台下有效。</li><li>&#x3D;&#x3D;close_fds&#x3D;&#x3D;： 如果该参数的值为True，则除了0,1和2之外的所有文件描述符都将会在子进程执行之前被关闭。</li><li>&#x3D;&#x3D;shell&#x3D;&#x3D;： 该参数用于标识是否使用shell作为要执行的程序，如果shell值为True，则建议将args参数作为一个字符串传递而不要作为一个序列传递。</li><li>&#x3D;&#x3D;cwd&#x3D;&#x3D;： 如果该参数值不是None，则该函数将会在执行这个子进程之前改变当前工作目录。</li><li>&#x3D;&#x3D;env&#x3D;&#x3D;： 用于指定子进程的环境变量，如果env&#x3D;None，那么子进程的环境变量将从父进程中继承。如果env!&#x3D;None，它的值必须是一个映射对象。</li><li>&#x3D;&#x3D;universal_newlines&#x3D;&#x3D;： 如果该参数值为True，则该文件对象的stdin，stdout和stderr将会作为文本流被打开，否则他们将会被作为二进制流被打开。</li><li>&#x3D;&#x3D;startupinfo&#x3D;&#x3D;和&#x3D;&#x3D;creationflags&#x3D;&#x3D;： 这两个参数只在Windows下有效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如主窗口的外观，进程优先级等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
      <category>技术知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件比较-filecmp库</title>
    <link href="/2021/11/03/%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83-filecmp%E5%BA%93/"/>
    <url>/2021/11/03/%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83-filecmp%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>filecmp库定义了用于比较文件和目录的函数。</p><h1 id="模块方法"><a href="#模块方法" class="headerlink" title="模块方法"></a>模块方法</h1><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>filecmp.cmp(f1, f2, shallow&#x3D;True)</td><td>比较名为f1和f2的文件，如果它们相等则返回True，否则返回False。</td></tr><tr><td>filecmp.cmpfiles(dir1, dir2, common, shallow&#x3D;True)</td><td>比较dir1和dir2两个目录中文件，文件的名字由common给出。返回三个文件名列表：match、mismatch、errors。mtach包含匹配文件的列表，mismatch包含不匹配文件的列表，errors列出无法比较的文件的名称。</td></tr></tbody></table><p>shallo参数告诉cmp()除了文件的元数据外，是否还要查看文件的内容。默认情况下，会使用由[[os库#os stat|os.stat()]]得到的信息来完成一个浅比较。如果结果是一样的，则认为文件相同。因此，对于同时创建的相同大小的文件，即使他们的内容不同，也会报告为是相同的文件。当shallow为False时，则要比较文件的内容。</p><h1 id="dircmp类"><a href="#dircmp类" class="headerlink" title="dircmp类"></a>dircmp类</h1><p>class filecmp.dircmp(a, b, ignore&#x3D;None, hide&#x3D;None)<br>构造一个新的目录比较对象，比较目录a和b。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>目录a</td></tr><tr><td>right</td><td>目录b</td></tr><tr><td>left_list</td><td>通过hide和ignore筛选后，a中的文件和子目录。</td></tr><tr><td>right_list</td><td>通过hide和ignore筛选后，b中的文件和子目录。</td></tr><tr><td>common</td><td>a和b中共同的文件和子目录</td></tr><tr><td>left_only</td><td>只是a 中的文件和子目录。</td></tr><tr><td>right_only</td><td>只是b 中的文件和子目录。</td></tr><tr><td>common_dirs</td><td>a和b中共同的子目录。</td></tr><tr><td>common_files</td><td>a和b中的文件。</td></tr><tr><td>common_funny</td><td>a和b中的名称，以使类型在目录之间不同，或os.stat()报告错误的名称。</td></tr><tr><td>same_files</td><td>a和b中相同的文件，使用该类的文件比较运算符。</td></tr><tr><td>diff_files</td><td>a和b中，根据该类的文件比较操作符，其内容不同的文件。</td></tr><tr><td>funny_files</td><td>a和b中无法比较的文件。</td></tr></tbody></table><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>report()</td><td>将a和b之间的比较打印</td></tr><tr><td>report_partial_closure()</td><td>打印a和b以及共有的直接子目录之间的比较</td></tr><tr><td>report_full_closure()</td><td>打印a和b以及共有的子目录（递归地）之间的比较</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
      <category>技术知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 读写excel</title>
    <link href="/2021/10/23/python%20%E8%AF%BB%E5%86%99excel/"/>
    <url>/2021/10/23/python%20%E8%AF%BB%E5%86%99excel/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在python中有许多中操作excel的方式，pandas无疑是最好用的，但是在平时写一些小工具时用其他小型包也够了。本篇介绍一下xlutis、xlrd、xlwt的一些基本操作。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="xlrd"><a href="#xlrd" class="headerlink" title="xlrd"></a>xlrd</h2><h3 id="单元格中的数据类型"><a href="#单元格中的数据类型" class="headerlink" title="单元格中的数据类型"></a>单元格中的数据类型</h3><p>empty、string、number、date、boolean、error、blank</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlrd<br><span class="hljs-keyword">import</span> datetime<br><br>data = xlrd.open_workbook(<span class="hljs-string">&#x27;excel.xlsx&#x27;</span>)<br><span class="hljs-comment">#读取路径,指向该路径上excel表格</span><br><br><span class="hljs-comment">#sheet的操作</span><br>table=data.sheets()[<span class="hljs-number">0</span>]                               <br><span class="hljs-comment">#通过索引获取</span><br>table=data.sheet_by_index(<span class="hljs-number">0</span>)                    <br><span class="hljs-comment">#通过索引获取</span><br>table=data.sheet_by_name(<span class="hljs-string">&#x27;sheet1&#x27;</span>)          <br><span class="hljs-comment">#通过名字获取</span><br><span class="hljs-comment">#以上三个函数返回一个xlrd.sheet.Sheet()对象</span><br><br>names=data.sheet_names()                        <br><span class="hljs-comment">#返回book中所有工作表的名字</span><br>data.sheet_loaded(name <span class="hljs-keyword">or</span> index)              <br><span class="hljs-comment">#检查工作簿是否已经导入，已导入返回true，未导入报错 xlrd.biffh.XLRDError</span><br><br><span class="hljs-comment">#对行、列的操作</span><br>table.nrows  <br><span class="hljs-comment">#返回工作簿的有效行数（有数据的行就会被计入）</span><br>table.row(rowx)  <br><span class="hljs-comment">#返回由该行中所有的单元格对象组成的列表 列表每个值的内容为： 单元类型：单元数据</span><br>table.row_slice(rowx,start_colx,end_colx) <br><span class="hljs-comment">#返回该列中从第[start_colx]到[end_colx]的单元格对象组成的列表</span><br>table.row_len(rows) <br><span class="hljs-comment">#返回该行的有效单元格长度（包括empty）</span><br>table.row_types(rows,start_colx,end_colx)<br><span class="hljs-comment">#返回该行单元类型组成的列表 0:empty 1:string 2:number 3:data 4:boolean 5:error</span><br>table.row_values(rows,start_colx,end_colx)<br><span class="hljs-comment">#返回该行的数据所组成的列表</span><br><br><span class="hljs-comment">#对单元格的操作</span><br>table.cell(rowx, colx) <br><span class="hljs-comment">#返回 [rowx,colx]的单元对象</span><br>table.cell_value(rowx, colx) <br><span class="hljs-comment">#返回 [rowx,colx]的值</span><br>table.cell_type(rowx, colx)<br><span class="hljs-comment">#返回[rowx,colx]的类型</span><br><br><span class="hljs-comment">#读取单元格内容为日期/时间的方式</span><br>date_tuple=xlrd.xldate_as_tuple(cell_value,data.datemode)<br><span class="hljs-comment">#若cell_value为时间，则将其转化为适用于datetime的元组</span><br>date_value=datetime.date(*date_tuple[:<span class="hljs-number">3</span>])<br><span class="hljs-comment">#转化为2019-02-07</span><br>date_value.strftime(<span class="hljs-string">&#x27;%Y%m%d&#x27;</span>) <br><span class="hljs-comment">#转化为2019/02/07格式</span><br><br><span class="hljs-comment">#对合并单元格的操作</span><br>table.merged_cells <br><span class="hljs-comment">#列出合并单元格和的信息,返回值为元组（包含坐标信息）的列表，无合并单元格返回空列表</span><br>table.cell_value(rowx_start,col_start)<br><span class="hljs-comment">#读取合并单元格的数据</span><br></code></pre></td></tr></table></figure><h2 id="xlutis"><a href="#xlutis" class="headerlink" title="xlutis"></a>xlutis</h2><p>xlutis是为了解决xlwt不能向已有数据的excel表格写入数据的局限性。主要使用的是xlutis.copy.copy方法，但是也有弊端，比如表格内的图片等内容不能复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">file_path = os.path.dirname(os.path.realpath(sys.executable))+<span class="hljs-string">&#x27;\\&#x27;</span>+book<br>book = xlrd.open_workbook(file_path,formatting_info=<span class="hljs-literal">True</span>)    <span class="hljs-comment"># 读取Excel</span><br><span class="hljs-comment"># 复制表</span><br>copy_book = xlutils.copy.copy(book) <span class="hljs-comment">#复制为xlwt可用的表</span><br>copy_sheet = copy_book.get_sheet(sheetname)<br><br></code></pre></td></tr></table></figure><h2 id="xlwt"><a href="#xlwt" class="headerlink" title="xlwt"></a>xlwt</h2><p>xlwt是一个比较简便的操作Excel表格的工具包，处理一些日常表格需求完全足够了。</p><h3 id="创建新表格"><a href="#创建新表格" class="headerlink" title="创建新表格"></a>创建新表格</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwt<br><br>workbook=xlwt.Workbook()<br>sheet = workbook.add_sheet(<span class="hljs-string">&#x27;sheet&#x27;</span>, cell_overwrite_ok=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#cell_overwrite_ok 默认为false,改为true将支持多次重写</span><br>sheet.col(<span class="hljs-number">0</span>).width = <span class="hljs-number">256</span> * <span class="hljs-number">15</span>  <br><span class="hljs-comment"># 设置第一列的宽度为15，宽度的基本单位为256.所以设置的时候一般用256 × 需要的列宽。</span><br><br>sheet.row(<span class="hljs-number">0</span>).height_mismatch = <span class="hljs-literal">True</span><br>sheet.row(<span class="hljs-number">0</span>).height = <span class="hljs-number">20</span> * <span class="hljs-number">40</span> <br><span class="hljs-comment"># 设置行高为可以修改，并修改为 40，行高的基本单位为20，设置同行高。</span><br>workbook.save(<span class="hljs-string">&#x27;Excel.xls&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="设置字体样式"><a href="#设置字体样式" class="headerlink" title="设置字体样式"></a>设置字体样式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">style=xlwt.XFStyle()<br><span class="hljs-comment">#初始化一个样式对象</span><br><br>font=xlwt.Font()<br><span class="hljs-comment">#创建字体样式</span><br>font.name=<span class="hljs-string">&quot;Simsun&quot;</span><br><span class="hljs-comment">#使用什么字体</span><br>font.height=<span class="hljs-number">20</span>*<span class="hljs-number">11</span><br><span class="hljs-comment">#Excel中字体大小对应的是11</span><br>font.bold=<span class="hljs-literal">False</span><br><span class="hljs-comment">#字体是否加粗</span><br>font.underline=<span class="hljs-literal">True</span><br><span class="hljs-comment">#是否有下划线</span><br>font.italic = <span class="hljs-literal">True</span><br><span class="hljs-comment">#是否倾斜字体</span><br>font.colour_index = <span class="hljs-number">0x01</span><br><span class="hljs-comment">#设置字体颜色</span><br><br>style.font=font<br><span class="hljs-comment">#设定为style中的样式</span><br></code></pre></td></tr></table></figure><h3 id="设置单元格样式"><a href="#设置单元格样式" class="headerlink" title="设置单元格样式"></a>设置单元格样式</h3><ol><li>设置对齐方式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#设置单元格居中</span><br>al1=xlwt.Alignment()<br>al1.horz=<span class="hljs-number">0x02</span><br>al1.vert=<span class="hljs-number">0x01</span><br>style.alignment=al1<br>sheet.write(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;al1居中方式&#x27;</span>,style)<br><br><span class="hljs-comment">#也可直接赋值</span><br>style.alignment.vert=<span class="hljs-number">0x01</span><br>style.alignment.horz=<span class="hljs-number">0x02</span><br><br> <span class="hljs-comment">#单元格对齐方式</span><br>VERT_TOP = <span class="hljs-number">0x00</span> 上端对齐<br>VERT_CENTER = <span class="hljs-number">0x01</span> 居中对齐（垂直方向上）<br>VERT_BOTTOM = <span class="hljs-number">0x02</span> 低端对齐<br><br>HORZ_LEFT = <span class="hljs-number">0x01</span> 左端对齐<br>HORZ_CENTER = <span class="hljs-number">0x02</span> 居中对齐（水平方向上）<br>HORZ_RIGHT = <span class="hljs-number">0x03</span> 右端对齐<br></code></pre></td></tr></table></figure></li></ol><p>在单元格设置超链接或公式等内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#在（0，0）中插入谷歌的超链接，并且在单元格内显示“Google”</span><br>sheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, xlwt.Formula(<span class="hljs-string">&#x27;HYPERLINK(&quot;http://www.google.com&quot;;&quot;Google&quot;)&#x27;</span>))<br><br><span class="hljs-comment">#添加其他表格的超链接</span><br>sheet.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, xlwt.Formula(<span class="hljs-string">&#x27;HYPERLINK(&quot;./test.xls&quot;;&quot;test&quot;)&#x27;</span>))<br><br><span class="hljs-comment">#添加公式</span><br>sheet.write(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, xlwt.Formula(<span class="hljs-string">&#x27;SUM(A1,A2)&#x27;</span>))<br></code></pre></td></tr></table></figure><p>写入日期</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#写入日期</span><br>style.num_format_str=<span class="hljs-string">&#x27;M/D/YY&#x27;</span><br>sheet.write(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, datetime.datetime.now(),style)<br></code></pre></td></tr></table></figure><p>设置单元格背景颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#设置单元格背景颜色</span><br>pattern.pattern = xlwt.Pattern()<br>pattern.pattern=SOLID_PATTERN<br>pattern.pattern_fore_colour=<span class="hljs-number">1</span><br><span class="hljs-comment">#颜色映射表见上</span><br>style.pattern=pattern<br></code></pre></td></tr></table></figure><p>设置单元格边框</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">borders=xlwt.Borders()<br>borders.left=xlwt.Borders.DASHED<br><span class="hljs-comment">#DASHED虚线</span><br><span class="hljs-comment">#NO_LINE没有</span><br><span class="hljs-comment">#THIN实线</span><br><span class="hljs-comment">#left 左 right 右 top 上 bottom 下</span><br><br><span class="hljs-comment">#设置边框颜色</span><br>borders.left_colour<br></code></pre></td></tr></table></figure><p>合并单元格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#write_merge(row,row+m,col,col+m,&#x27;lable&#x27;,style)</span><br></code></pre></td></tr></table></figure><p>隐藏某列某行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">sheet.row(i).hidden<br>=<span class="hljs-number">0</span>  显示<br>=<span class="hljs-number">1</span>  隐藏<br></code></pre></td></tr></table></figure><h3 id="设置页面布局"><a href="#设置页面布局" class="headerlink" title="设置页面布局"></a>设置页面布局</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">copy_sheet.portrait = <span class="hljs-literal">False</span><br>false 横向<br>true 纵向<br></code></pre></td></tr></table></figure><h3 id="去除页眉页脚"><a href="#去除页眉页脚" class="headerlink" title="去除页眉页脚"></a>去除页眉页脚</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">    copy_sheet.show_headers = <span class="hljs-literal">False</span><br>    copy_sheet.header_str = <span class="hljs-string">b&#x27;&#x27;</span><br>    copy_sheet.footer_str = <span class="hljs-string">b&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
      <category>技术知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动启动程序工具</title>
    <link href="/2021/10/23/%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/10/23/%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>机房里新的广播服务器有几个软件重启的时候需要手动启动，放入启动文件夹只能启动程序本体，但是服务还是需要手动启动，而且机房的键盘容易卡住，鼠标延迟严重，有误操作的可能，所以我写了个小工具自动启动。<br>主要使用pyautoui这个库进行屏幕图像识别及自动操作。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#-*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> pyautogui<br><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> subprocess<br><br>  <br><br>_path = os.path.dirname(os.path.realpath(sys.executable))<br><br>img_path = _path +<span class="hljs-string">&quot;\\imgs&quot;</span><br><br>  <br><br>_cmd = _path +<span class="hljs-string">&#x27;\\startandclick\\&#x27;</span><br><br>_cmdnoclick = _path +<span class="hljs-string">&#x27;\\onlystart\\&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">listpath</span>(<span class="hljs-params">path</span>):<br><br> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(path):<br><br> os.makedirs(path)<br><br> imgs = os.listdir(path)<br><br> <span class="hljs-keyword">return</span> imgs<br><br>  <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br> imgdir = os.listdir(img_path)<br><br> _rjc = listpath(_cmd)<br><br> _rjo = listpath(_cmdnoclick)<br><br> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(imgdir)):<br><br> newimgpath = img_path+<span class="hljs-string">&quot;\\&quot;</span>+imgdir[j]<br><br> imgslist = listpath(newimgpath)<br><br> subprocess.Popen(_cmd+_rjc[j],stdout=subprocess.PIPE, shell=<span class="hljs-literal">True</span>)<br><br> time.sleep(<span class="hljs-number">0.8</span>)<br><br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(imgslist)):<br><br> <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br> location=pyautogui.locateCenterOnScreen(newimgpath+<span class="hljs-string">&#x27;\\&#x27;</span>+imgslist[i])<br><br> <span class="hljs-keyword">if</span> location <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br><br> pyautogui.click(location.x,location.y,duration=<span class="hljs-number">0.2</span>,button=<span class="hljs-string">&#x27;left&#x27;</span>)<br><br> <span class="hljs-keyword">break</span><br><br> time.sleep(<span class="hljs-number">0.2</span>)<br><br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;点击任务&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;执行成功！&quot;</span>)<br><br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(_rjo)):<br><br> subprocess.Popen(_cmdnoclick+_rjo[i],stdout=subprocess.PIPE, shell=<span class="hljs-literal">True</span>)<br><br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;启动任务&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;执行成功！&quot;</span>)<br><br> time.sleep(<span class="hljs-number">0.5</span>)<br><br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---------------------------------------&quot;</span>)<br><br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所有任务执行成功！&quot;</span>)<br><br> time.sleep(<span class="hljs-number">0.5</span>)<br><br> sys.exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小工具</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动启动程序工具</title>
    <link href="/2021/10/13/excel2cfg%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/10/13/excel2cfg%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个小程序是为了解决pet项目中写配置表的问题。主要功能是把excel表转换为程序可以使用的.cfg格式文件。方便策划直观的填写数据。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> xlrd<br><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> sys<br><br>  <br><br><span class="hljs-comment"># path = &#x27;F:\\代码仓库\\study\\excel2cfg\\table&#x27;</span><br><br><span class="hljs-comment"># cfgpath = &quot;F:\\代码仓库\\study\\excel2cfg\\cfg&quot;</span><br><br>  <br><br><span class="hljs-comment"># path = &#x27;E:\\代码仓库\\study\\excel2cfg\\table&#x27;</span><br><br><span class="hljs-comment"># cfgpath = &#x27;E:\\代码仓库\\study\\excel2cfg\\cfg&#x27;</span><br><br>  <br><br>exepath = os.path.dirname(os.path.realpath(sys.executable))<br><br>path = exepath+<span class="hljs-string">&#x27;\\table&#x27;</span><br><br>cfgpath = exepath+<span class="hljs-string">&#x27;\\Config&#x27;</span><br><br>  <br><br><span class="hljs-comment"># 读取help.txt中的数据 xlsx中的数据并且保存为cfg</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">readData</span>(<span class="hljs-params">files,dirname</span>):<br><br> _cfgpath=cfgpath+<span class="hljs-string">&#x27;\\&#x27;</span>+dirname+<span class="hljs-string">&#x27;.cfg&#x27;</span><br><br> exists(_cfgpath)<br><br> data=<span class="hljs-string">&#x27;&#x27;</span><br><br> <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br><br> <span class="hljs-keyword">if</span> file == <span class="hljs-string">&#x27;help.txt&#x27;</span>:<br><br> _lpath=_path+<span class="hljs-string">&#x27;\\&#x27;</span>+file<br><br> <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(_lpath,<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br><br> data = f.read()<br><br> f.close<br><br> data += <span class="hljs-string">&#x27;\n[data]\n&#x27;</span><br><br>  <br><br> <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br><br> <span class="hljs-keyword">if</span> file != <span class="hljs-string">&#x27;help.txt&#x27;</span>:<br><br> _lpath=_path+<span class="hljs-string">&#x27;\\&#x27;</span>+file<br><br>  <br><br> wb=xlrd.open_workbook(_lpath)<br><br> sheet=wb.sheet_by_index(<span class="hljs-number">0</span>)<br><br> rows=sheet.nrows<br><br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,rows):<br><br> thislist = sheet.row_values(i)<br><br> typelist = sheet.row_types(i)<br><br> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(thislist)):<br><br> thisvalue = thislist[j]<br><br> <span class="hljs-keyword">if</span> typelist[j] == <span class="hljs-number">2</span>:<br><br> thisvalue = <span class="hljs-built_in">int</span>(thisvalue)<br><br> <span class="hljs-keyword">if</span> j==<span class="hljs-built_in">len</span>(thislist)-<span class="hljs-number">1</span>:<br><br> data = data + <span class="hljs-built_in">str</span>(thisvalue)<br><br> <span class="hljs-keyword">else</span>:<br><br> data = data + <span class="hljs-built_in">str</span>(thisvalue) + <span class="hljs-string">&#x27;\t&#x27;</span><br><br> data += <span class="hljs-string">&#x27;\n&#x27;</span><br><br>  <br><br> <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(_cfgpath,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br><br> f.write(data)<br><br> f.close()<br><br>  <br><br><span class="hljs-comment"># 判断文件是否存在</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exists</span>(<span class="hljs-params"><span class="hljs-built_in">dir</span></span>):<br><br> temp = os.path.exists(<span class="hljs-built_in">dir</span>)<br><br> <span class="hljs-keyword">if</span> temp == <span class="hljs-literal">False</span>:<br><br> <span class="hljs-built_in">open</span>(<span class="hljs-built_in">dir</span>,<span class="hljs-string">&#x27;w&#x27;</span>)<br><br>  <br>  <br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br><br> <span class="hljs-comment"># 读取当前文件夹下的所有文件</span><br><br> dirs=os.listdir(path)<br><br> <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> dirs:<br><br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在写入&quot;</span>+<span class="hljs-built_in">dir</span>+<span class="hljs-string">&#x27;.cfg......&#x27;</span>)<br><br> _path = path+<span class="hljs-string">&#x27;\\&#x27;</span>+<span class="hljs-built_in">dir</span><br><br> files = os.listdir(_path)<br><br> readData(files,<span class="hljs-built_in">dir</span>)<br><br> <span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>+<span class="hljs-string">&#x27;.cfg 写入完毕。&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小工具</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好用的开源笔记-Joplin</title>
    <link href="/2021/09/27/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BC%80%E6%BA%90%E7%AC%94%E8%AE%B0-Joplin/"/>
    <url>/2021/09/27/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BC%80%E6%BA%90%E7%AC%94%E8%AE%B0-Joplin/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近花了很多时间寻找一款私有化笔记，我的需求如下 </p><blockquote><ul><li>开源</li><li>可私有化部署</li><li>笔记文件保存在本地</li><li>支持多端同步</li><li>支持双链</li><li>最好支持markdown所见所得</li><li>迁移笔记方便</li></ul></blockquote><p>我这段时间试用了为知笔记Docker版、Trilium、思源笔记、Mrdoc、showdoc、Obsidian等笔记软件，诚然，这些软件都有独特的优点，但是对我而言也有一些缺点。其中尤其让我惊喜的是为知笔记Docker版本，搭配重构版客户端，体验上比其他软件高出许多。但是或许是其重构版目前仍然处于开发早期，存在许多令我别扭的功能，比如图片强制保存在本地等，必须点击展开，才能打开下一层笔记本 等。</p><p>这些别扭让我决定转移阵地，毕竟我是一个习惯了就不喜欢改变的人，所以对笔记软件也是希望一步到位，选择最适合的。所以最终决定使用Joplin作为主力笔记软件。</p><p>之前也试用过Joplin，但是当时被其同步功能劝退，这次解决了同步问题，所以记录一下。</p><p>Joplin的好处非常之多，比如有丰富的插件库、开源、笔记保存在本地、多种同步方式、完美的网页剪辑功能、最重要的是还支持调用Typore编辑。作为一个免费软件，真的是让人感叹它也太全能了。</p><p>下面记录一下Joplin搭配FileRun进行同步的设置</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="joplin的安装"><a href="#joplin的安装" class="headerlink" title="joplin的安装"></a>joplin的安装</h2><p>打开Joplin的官网：<a href="https://joplinapp.org/">Joplin (joplinapp.org)</a></p><p>Joplin支持多端，选择需要的客户端下载安装即可，方便的不行。安装后，打开Joplin即可使用。</p><h2 id="FileRun的部署"><a href="#FileRun的部署" class="headerlink" title="FileRun的部署"></a>FileRun的部署</h2><p>FileRun是一款免费的私有化部署网盘，是我一直在用的网盘，如果你觉得nextcloud太臃肿，不妨试试这一款，轻量级的同时，该有的功能一样都不少。</p><p>因为我已经部署了FileRun，所以这里简单的概括一下安装方法，前往官网<a href="https://www.filerun.com/">FileRun</a>下载网站源码压缩包，上传到你网站的根目录下，浏览器打开：<code>你的域名/filerun</code> 根据提示安装即可。</p><p>FileRun如此轻量级的网页程序居然还支持WebDAV，开发者真是很贴心了啊。</p><p>FileRun访问WebDAV的链接为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http(s):<span class="hljs-regexp">//</span>你的域名<span class="hljs-regexp">/dav.php/</span>@<span class="hljs-number">40</span>Home/<br></code></pre></td></tr></table></figure><p>貌似不支持浏览器直接访问，不过咱也不需要这个功能。</p><p>到此FileRun部署结束，重头戏在下面，我配置Joplin的WebDAV同步踩了不少坑。</p><h2 id="配置同步"><a href="#配置同步" class="headerlink" title="配置同步"></a>配置同步</h2><p>打开【工具】-【选项】-【同步】，可以看到joplin支持非常多的同步方式，在这里我当然选择使用WebDAV的同步方式</p><p><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030190156.png"></p><p>根据提示，填入WebDAV URL ，FIleRun用户名和密码，我这里填入的是http的域名，点击检查同步配置。嗯…提示成功，看起来没问题</p><p><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030190233.png"></p><p>第一个坑，检查同步配置没问题，可是在笔记中点击同步后，却出了问题</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Last <span class="hljs-keyword">error</span>: Error: Could <span class="hljs-keyword">not</span> upgrade <span class="hljs-keyword">from</span> <span class="hljs-built_in">version</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">version</span> <span class="hljs-number">1</span>: MKCOL ./sync/: Unknown <span class="hljs-keyword">error</span> <span class="hljs-number">2</span> (<span class="hljs-number">403</span>): You are <span class="hljs-keyword">not</span> allowed <span class="hljs-keyword">to</span> use this folder <span class="hljs-built_in">name</span>!<br></code></pre></td></tr></table></figure><p>看这提示，我横看竖看，不知道问题出在哪里，看上去好像是读取或创建文件的时候出了错误，于是求助百度，逛了一圈我发现，竟然一个出现类似问题的都没有，估计是国内Joplin用户少，Filerun用户少，Joplin+Filerun的用户就更少了，无奈只能上官网寻找帮助。</p><p>在官方帮助文档的一个角落里发现了官方对此有做说明</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">FileRun doesn&#x27;t allow currently to <span class="hljs-keyword">create</span> hidden folders (name starting <span class="hljs-keyword">with</span> a dot), that <span class="hljs-keyword">is</span> why it fails because Joplin tries <span class="hljs-keyword">to</span> <span class="hljs-keyword">create</span> a hidden folder. There <span class="hljs-keyword">is</span> a workaround. <span class="hljs-keyword">Create</span> a configuration file <span class="hljs-keyword">and</span> add this <span class="hljs-keyword">to</span> it:<br><br>$config[<span class="hljs-string">&#x27;app&#x27;</span>][<span class="hljs-string">&#x27;hidden_folder_names&#x27;</span>] = [<span class="hljs-string">&#x27;.filerun.*&#x27;</span>];<br></code></pre></td></tr></table></figure><p>意思是FileRun不允许创建隐藏的文件夹，而Joplin在同步过程中会创建隐藏文件夹，所以在上面会报错。知道了问题和解决办法后，就好办了，根据文档指导，在网站根目录下的<code>customizables</code>下创建 <code>config.php</code>文件，在其中加入一行配置</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">$config[<span class="hljs-string">&#x27;app&#x27;</span>][<span class="hljs-string">&#x27;hidden_folder_names&#x27;</span>] = [<span class="hljs-string">&#x27;.filerun.*&#x27;</span>];<br></code></pre></td></tr></table></figure><p>注意，这里还有一个坑，记得在文件首行写入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br></code></pre></td></tr></table></figure><p>否则配置会读取失败。</p><p>第二个坑、按照如上操作后windows平台确实是可以同步了，但是手机平台却死活也连不上，后来琢磨是不是手机平台不支持http链接，于是我将网站开启了SSL，并且将WebDAV链接改成了https，点击同步，出现如下错误</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">reason: unable <span class="hljs-built_in">to</span> verify <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> certificate (Code UNABLE_TO_VERIFY_LEAF_SIGNATURE)<br></code></pre></td></tr></table></figure><p>查阅一番资料后，估计是Joplin对免费SSL证书的认证有问题，目前的解决方案是打开【高级选项】，勾选上【忽略TLS证书错误】</p><p><img src="https://cdn.jsdelivr.net/gh/dvai/imageshost//img/20221030190302.png"></p><p>经过以上折腾后，Joplin终于支持全平台同步了，而且保存的笔记文件在FileRun中也可以查看，舒服了。</p>]]></content>
    
    
    <categories>
      
      <category>好软推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记软件</tag>
      
      <tag>开源工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对文件的基本操作-os库</title>
    <link href="/2021/09/24/%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-os%E5%BA%93/"/>
    <url>/2021/09/24/%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-os%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>python 中的 os 模块提供了非常丰富的方法用来处理文件和目录。是一个非常常用的模块。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="os-access-path-mode"><a href="#os-access-path-mode" class="headerlink" title="os.access(path,mode)"></a>os.access(path,mode)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>用于检测某个文件有什么属性</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>path –  要用来检测是否有访问权限的路径。</li><li>mode – 需要测试的权限<ul><li>os.F_OK:  测试path是否存在。</li><li>os.R_OK:  测试path是否可读。</li><li>os.W_OK：测试path是否可写。</li><li>os.X_OK： 测试path是否可执行。</li></ul></li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果允许访问返回 True , 否则返回False。</p><h2 id="os-chdir-path"><a href="#os-chdir-path" class="headerlink" title="os.chdir(path)"></a>os.chdir(path)</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>用于改变当前工作目录到指定路径。</p><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li>path – 要切换到的新路径。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>如果允许访问返回 True , 否则返回False。</p><h2 id="os-chmod-path-mode"><a href="#os-chmod-path-mode" class="headerlink" title="os.chmod(path,mode)"></a>os.chmod(path,mode)</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>用于更改文件或目录的权限</p><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul><li><p><strong>path</strong> – 文件名路径或目录路径。</p></li><li><p><strong>flags</strong> – 可用以下选项按位或操作生成， 目录的读权限表示可以获取目录里文件名列表， ，执行权限表示可以把工作目录切换到此目录 ，删除添加目录里的文件必须同时有写和执行权限 ，文件权限以用户id-&gt;组id-&gt;其它顺序检验,最先匹配的允许或禁止权限被应用。</p><ul><li><strong>stat.S_IXOTH:</strong> 其他用户有执行权0o001</li><li><strong>stat.S_IWOTH:</strong> 其他用户有写权限0o002</li><li><strong>stat.S_IROTH:</strong> 其他用户有读权限0o004</li><li><strong>stat.S_IRWXO:</strong> 其他用户有全部权限(权限掩码)0o007</li><li><strong>stat.S_IXGRP:</strong> 组用户有执行权限0o010</li><li><strong>stat.S_IWGRP:</strong> 组用户有写权限0o020</li><li><strong>stat.S_IRGRP:</strong> 组用户有读权限0o040</li><li><strong>stat.S_IRWXG:</strong> 组用户有全部权限(权限掩码)0o070</li><li><strong>stat.S_IXUSR:</strong> 拥有者具有执行权限0o100</li><li><strong>stat.S_IWUSR:</strong> 拥有者具有写权限0o200</li><li><strong>stat.S_IRUSR:</strong> 拥有者具有读权限0o400</li><li><strong>stat.S_IRWXU:</strong> 拥有者有全部权限(权限掩码)0o700</li><li><strong>stat.S_ISVTX:</strong> 目录里文件目录只有拥有者才可删除更改0o1000</li><li><strong>stat.S_ISGID:</strong> 执行此文件其进程有效组为文件所在组0o2000</li><li><strong>stat.S_ISUID:</strong> 执行此文件其进程有效用户为文件所有者0o4000</li><li><strong>stat.S_IREAD:</strong> windows下设为只读</li><li><strong>stat.S_IWRITE:</strong> windows下取消只读</li></ul></li></ul><h2 id="os-close-fd"><a href="#os-close-fd" class="headerlink" title="os.close(fd)"></a>os.close(fd)</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>用于关闭文件描述符（引用），一般用open等函数打开文件的话，最后都需要用os.close()进行关闭。</p><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><ul><li>fd – 文件描述符</li></ul><h2 id="os-getcwd"><a href="#os-getcwd" class="headerlink" title="os.getcwd()"></a>os.getcwd()</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>用于返回当前工作目录</p><h2 id="os-listdir-path"><a href="#os-listdir-path" class="headerlink" title="os.listdir(path)"></a>os.listdir(path)</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。</p><h2 id="os-link-src-dst"><a href="#os-link-src-dst" class="headerlink" title="os.link(src, dst)"></a>os.link(src, dst)</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>该方法可以用于创建硬链接，该硬连接可以随着源地址文件改动而实时改动</p><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><ul><li>src – 源地址</li><li>dst – 目标地址</li></ul><h2 id="os-mkdir-path-mode"><a href="#os-mkdir-path-mode" class="headerlink" title="os.mkdir(path[,mode])"></a>os.mkdir(path[,mode])</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>os.mkdir() 方法用于以数字权限模式创建目录。默认的模式为 0777 (八进制)。<br>如果目录有多级，则创建最后一级，如果最后一级目录的上级目录有不存在的，则会抛出一个 OSError。</p><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><ul><li>path – 要创建的目录，可以是相对或者绝对路径。</li><li>mode – 要为目录设置的权限数字模式。</li></ul><h2 id="os-open-file-flags-mode"><a href="#os-open-file-flags-mode" class="headerlink" title="os.open(file,flags[,mode])"></a>os.open(file,flags[,mode])</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>os.open() 方法用于打开一个文件，并且设置需要的打开选项，模式参数mode参数是可选的，默认为 0777。<br>注意与open()函数做区别，open返回的是文件对象，而open返回的是文件描述符</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>**open()**方法语法格式如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">os.<span class="hljs-keyword">open</span>(file, flags\<span class="hljs-comment">[, mode\]</span>);<br></code></pre></td></tr></table></figure><h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><ul><li><p><strong>file</strong> – 要打开的文件</p></li><li><p><strong>flags</strong> – 该参数可以是以下选项，多个使用 “|” 隔开：</p><ul><li><strong>os.O_RDONLY:</strong> 以只读的方式打开</li><li><strong>os.O_WRONLY:</strong> 以只写的方式打开</li><li><strong>os.O_RDWR :</strong> 以读写的方式打开</li><li><strong>os.O_NONBLOCK:</strong> 打开时不阻塞</li><li><strong>os.O_APPEND:</strong> 以追加的方式打开</li><li><strong>os.O_CREAT:</strong> 创建并打开一个新文件</li><li><strong>os.O_TRUNC:</strong> 打开一个文件并截断它的长度为零（必须有写权限）</li><li><strong>os.O_EXCL:</strong> 如果指定的文件存在，返回错误</li><li><strong>os.O_SHLOCK:</strong> 自动获取共享锁</li><li><strong>os.O_EXLOCK:</strong> 自动获取独立锁</li><li><strong>os.O_DIRECT:</strong> 消除或减少缓存效果</li><li><strong>os.O_FSYNC :</strong> 同步写入</li><li><strong>os.O_NOFOLLOW:</strong> 不追踪软链接</li></ul></li><li><p><strong>mode</strong> – 类似[[os库#os chmod path mode|chmod()]]</p></li></ul><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>返回新打开文件的描述符。</p><h2 id="os-pipe"><a href="#os-pipe" class="headerlink" title="os.pipe()"></a>os.pipe()</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p>os.pipe() 方法用于创建一个管道, 返回一对文件描述符(r, w) 分别为读和写。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>**pipe()**方法语法格式如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">os.pipe<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><h3 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h3><ul><li>无</li></ul><h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>返回文件描述符对。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例演示了 pipe() 方法的使用：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br>import os, sys<br><br>print <span class="hljs-string">&quot;The child will write text to a pipe and &quot;</span><br>print <span class="hljs-string">&quot;the parent will read the text written by child...&quot;</span><br><br><span class="hljs-comment"># file descriptors r, w for reading and writing</span><br>r, w = os.pipe() <br><br>processid = os.fork()<br><span class="hljs-keyword">if</span> processid:<br>    <span class="hljs-comment"># This is the parent process </span><br>    <span class="hljs-comment"># Closes file descriptor w</span><br>    os.close(w)<br>    r = os.fdopen(r)<br>    print <span class="hljs-string">&quot;Parent reading&quot;</span><br>    str = r.read()<br>    print <span class="hljs-string">&quot;text =&quot;</span>, str   <br>    sys.<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># This is the child process</span><br>    os.close(r)<br>    w = os.fdopen(w, <span class="hljs-string">&#x27;w&#x27;</span>)<br>    print <span class="hljs-string">&quot;Child writing&quot;</span><br>    w.write(<span class="hljs-string">&quot;Text written by child...&quot;</span>)<br>    w.close()<br>    print <span class="hljs-string">&quot;Child closing&quot;</span><br>    sys.<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>执行以上程序输出结果为：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The child will <span class="hljs-built_in">write</span> <span class="hljs-keyword">text</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> pipe <span class="hljs-keyword">and</span><br><span class="hljs-keyword">the</span> parent will <span class="hljs-built_in">read</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">text</span> written <span class="hljs-keyword">by</span> child...<br>Parent reading<br>Child writing<br>Child closing<br><span class="hljs-keyword">text</span> = Text written <span class="hljs-keyword">by</span> child...<br></code></pre></td></tr></table></figure><h2 id="os-remove-file"><a href="#os-remove-file" class="headerlink" title="os.remove(file)"></a>os.remove(file)</h2><h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><p>移除一个文件</p><h2 id="os-removedirs-path"><a href="#os-removedirs-path" class="headerlink" title="os.removedirs(path)"></a>os.removedirs(path)</h2><h3 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h3><p>递归删除一个目录</p><h2 id="os-rename-src-dst"><a href="#os-rename-src-dst" class="headerlink" title="os.rename(src,dst)"></a>os.rename(src,dst)</h2><h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><p>该方法用于命名文件或目录，如果dst是一个存在的目录, 将抛出OSError。</p><h2 id="os-renames-old-new"><a href="#os-renames-old-new" class="headerlink" title="os.renames(old,new)"></a>os.renames(old,new)</h2><h3 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h3><p>与rename()的区别是，该方法可以创建不存在的目录，而rename()使用不存在的目录时会报错。</p><h2 id="os-rmdir-path"><a href="#os-rmdir-path" class="headerlink" title="os.rmdir(path)"></a>os.rmdir(path)</h2><h3 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h3><p>该方法用于删除指定路径的目录。仅当这文件夹是空的才可以, 否则, 抛出OSError。</p><h2 id="os-stat"><a href="#os-stat" class="headerlink" title="os.stat()"></a>os.stat()</h2><h3 id="概述-15"><a href="#概述-15" class="headerlink" title="概述"></a>概述</h3><p>os.stat() 方法用于在给定的路径上执行一个系统 stat 的调用。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>**stat()**方法语法格式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">os</span>.stat(<span class="hljs-built_in">path</span>)<br></code></pre></td></tr></table></figure><h3 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>path</strong> – 指定路径</li></ul><h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><p>stat 结构:</p><ul><li><strong>st_mode:</strong> inode 保护模式</li><li><strong>st_ino:</strong> inode 节点号。</li><li><strong>st_dev:</strong> inode 驻留的设备。</li><li><strong>st_nlink:</strong> inode 的链接数。</li><li><strong>st_uid:</strong> 所有者的用户ID。</li><li><strong>st_gid:</strong> 所有者的组ID。</li><li><strong>st_size:</strong> 普通文件以字节为单位的大小；包含等待某些特殊文件的数据。</li><li><strong>st_atime:</strong> 上次访问的时间。</li><li><strong>st_mtime:</strong> 最后一次修改的时间。</li><li><strong>st_ctime:</strong> 由操作系统报告的”ctime”。在某些系统上（如Unix）是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）。</li></ul><h2 id="os-symlink-src-dst"><a href="#os-symlink-src-dst" class="headerlink" title="os.symlink(src,dst)"></a>os.symlink(src,dst)</h2><h3 id="概述-16"><a href="#概述-16" class="headerlink" title="概述"></a>概述</h3><p>创建一个软链接，但是需要管理员权限</p><h2 id="os-write-fd-str"><a href="#os-write-fd-str" class="headerlink" title="os.write(fd,str)"></a>os.write(fd,str)</h2><h3 id="概述-17"><a href="#概述-17" class="headerlink" title="概述"></a>概述</h3><p>os.write() 方法用于写入字符串到文件描述符 fd 中. 返回实际写入的字符串长度。</p><p>在Unix中有效。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>**write()**方法语法格式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">os</span>.<span class="hljs-built_in">write</span>(fd, str)<br></code></pre></td></tr></table></figure><h3 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h3><ul><li><p><strong>fd</strong> – 文件描述符。</p></li><li><p><strong>str</strong> – 写入的字符串。</p></li></ul><h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><p>该方法返回写入的实际位数。</p><h2 id="os-path模块"><a href="#os-path模块" class="headerlink" title="os.path模块"></a>os.path模块</h2><p>以下是 os.path 模块的几种常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>os.path.abspath(path)</td><td>返回绝对路径</td></tr><tr><td>os.path.basename(path)</td><td>返回文件名</td></tr><tr><td>os.path.commonprefix(list)</td><td>返回list(多个路径)中，所有path共有的最长的路径</td></tr><tr><td>os.path.dirname(path)</td><td>返回文件路径</td></tr><tr><td>os.path.exists(path)</td><td>如果路径 path 存在，返回 True；如果路径 path 不存在，返回 False。</td></tr><tr><td>os.path.lexists</td><td>路径存在则返回True,路径损坏也返回True</td></tr><tr><td>os.path.expanduser(path)</td><td>把path中包含的”<del>“和”</del>user”转换成用户目录</td></tr><tr><td>os.path.expandvars(path)</td><td>根据环境变量的值替换path中包含的”$name”和”${name}”</td></tr><tr><td>os.path.getatime(path)</td><td>返回最近访问时间（浮点型秒数）</td></tr><tr><td>os.path.getmtime(path)</td><td>返回最近文件修改时间</td></tr><tr><td>os.path.getctime(path)</td><td>返回文件 path 创建时间</td></tr><tr><td>os.path.getsize(path)</td><td>返回文件大小，如果文件不存在就返回错误</td></tr><tr><td>os.path.isabs(path)</td><td>判断是否为绝对路径</td></tr><tr><td>os.path.isfile(path)</td><td>判断路径是否为文件</td></tr><tr><td>os.path.isdir(path)</td><td>判断路径是否为目录</td></tr><tr><td>os.path.islink(path)</td><td>判断路径是否为链接</td></tr><tr><td>os.path.ismount(path)</td><td>判断路径是否为挂载点</td></tr><tr><td>os.path.join(path1[, path2[, …]])</td><td>把目录和文件名合成一个路径</td></tr><tr><td>os.path.normcase(path)</td><td>转换path的大小写和斜杠</td></tr><tr><td>os.path.normpath(path)</td><td>规范path字符串形式</td></tr><tr><td>os.path.realpath(path)</td><td>返回path的真实路径</td></tr><tr><td>os.path.relpath(path[, start])</td><td>从start开始计算相对路径</td></tr><tr><td>os.path.samefile(path1, path2)</td><td>判断目录或文件是否相同</td></tr><tr><td>os.path.sameopenfile(fp1, fp2)</td><td>判断fp1和fp2是否指向同一文件</td></tr><tr><td>os.path.samestat(stat1, stat2)</td><td>判断stat tuple stat1和stat2是否指向同一个文件</td></tr><tr><td>os.path.split(path)</td><td>把路径分割成 dirname 和 basename，返回一个元组</td></tr><tr><td>os.path.splitdrive(path)</td><td>一般用在 windows 下，返回驱动器名和路径组成的元组</td></tr><tr><td>os.path.splitext(path)</td><td>分割路径，返回路径名和文件扩展名的元组</td></tr><tr><td>os.path.splitunc(path)</td><td>把路径分割为加载点与文件</td></tr><tr><td>os.path.walk(path, visit, arg)</td><td>遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数</td></tr><tr><td>os.path.supports_unicode_filenames</td><td>设置是否支持unicode路径名</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
      <category>技术知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python内置函数</title>
    <link href="/2021/08/13/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <url>/2021/08/13/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>python中支持一些内置函数，下文对一些常用函数做介绍</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="abs-x"><a href="#abs-x" class="headerlink" title="abs(x)"></a>abs(x)</h2><p>返回数字的绝对值</p><h2 id="all-iterable"><a href="#all-iterable" class="headerlink" title="all(iterable)"></a>all(iterable)</h2><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。<br>元素除了是 0、空、None、False 外都算 True。<br>函数等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">iterable</span>):  <br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> iterable:  <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> element:  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <br><br>Python <span class="hljs-number">2.5</span> 以上版本可用。<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>iterable – 元组或列表。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果iterable的所有元素不为0、’’、False或者iterable为空，all(iterable)返回True，否则返回False；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ad-note">title:注意<br>空元组、空列表返回值为True，这里要特别注意。<br></code></pre></td></tr></table></figure><h2 id="any-iterable"><a href="#any-iterable" class="headerlink" title="any(iterable)"></a>any(iterable)</h2><p>any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True。<br>元素除了是 0、空、FALSE 外都算 TRUE。</p><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>iterable – 元组或列表。</p><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。</p><h2 id="bool-x"><a href="#bool-x" class="headerlink" title="bool(x)"></a>bool(x)</h2><p>将给定参数转为布尔类型，如果没有参数则返回false<br>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-built_in">bool</span>()<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-number">0</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-number">2</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">issubclass</span>(<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">int</span>)  <span class="hljs-comment"># bool 是 int 子类</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="chr-i"><a href="#chr-i" class="headerlink" title="chr(i)"></a>chr(i)</h2><p>将一个范围在range(256)(0~255)的整数作为参数（ASCII编码）转为相应的ASCII字符</p><h2 id="cmp-x-y"><a href="#cmp-x-y" class="headerlink" title="cmp(x,y)"></a>cmp(x,y)</h2><p>cmp(x,y) 函数用于比较2个对象(数值表达式)，如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1。</p><h2 id="delattr-object-name"><a href="#delattr-object-name" class="headerlink" title="delattr(object,name)"></a>delattr(object,name)</h2><p>用于删除属性，<br><code>delattr(x,&#39;foobar&#39;)</code>相当于<code>del x.foobar</code></p><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>object –对象<br>name – 必须是对象的属性</p><h2 id="dict"><a href="#dict" class="headerlink" title="dict()"></a>dict()</h2><p>用于创建一个字典</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">dict</span>(**kwarg)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dict</span>(mapping, **kwarg)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dict</span>(iterable, **kwarg)<br></code></pre></td></tr></table></figure><p>参数说明</p><blockquote><p>kwargs – 关键字。<br>mapping – 元素的容器，映射类型（Mapping Types）是一种关联式的容器类型，它存储了对象与对象之间的映射关系。<br>iterable – 可迭代对象。</p></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-built_in">dict</span>()                        <span class="hljs-comment"># 创建空字典</span><br>&#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>(a=<span class="hljs-string">&#x27;a&#x27;</span>, b=<span class="hljs-string">&#x27;b&#x27;</span>, t=<span class="hljs-string">&#x27;t&#x27;</span>)     <span class="hljs-comment"># 传入关键字</span><br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>: <span class="hljs-string">&#x27;t&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>([<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))   <span class="hljs-comment"># 映射函数方式来构造字典</span><br>&#123;<span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>&#125; <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>([(<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-number">3</span>)])    <span class="hljs-comment"># 可迭代对象方式来构造字典</span><br>&#123;<span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>&#125;<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h2 id="divmod-a-b"><a href="#divmod-a-b" class="headerlink" title="divmod(a,b)"></a>divmod(a,b)</h2><p>除数和余数运算结果结合起来，返回一个包含商和余数的元组(a &#x2F;&#x2F; b, a % b)。</p><h2 id="enumerate-sequence-start-x3D-0"><a href="#enumerate-sequence-start-x3D-0" class="headerlink" title="enumerate(sequence[, start&#x3D;0])"></a>enumerate(sequence[, start&#x3D;0])</h2><p>一般用于for循环中</p><p>普通的for循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;i = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>seq = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> seq:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span> i, seq[i]<br><span class="hljs-meta">... </span>    i +=<span class="hljs-number">1</span><br><span class="hljs-meta">... </span><br><span class="hljs-number">0</span> one<br><span class="hljs-number">1</span> two<br><span class="hljs-number">2</span> three<br></code></pre></td></tr></table></figure><p>使用enumerate的for循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;seq = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i, element <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(seq):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span> i, element<br><span class="hljs-meta">... </span><br><span class="hljs-number">0</span> one<br><span class="hljs-number">1</span> two<br><span class="hljs-number">2</span> three<br></code></pre></td></tr></table></figure><h2 id="filter-function-iterable"><a href="#filter-function-iterable" class="headerlink" title="filter(function,iterable)"></a>filter(function,iterable)</h2><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。</p><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><blockquote><p>function – 判断的函数<br>iterable – 可迭代对象</p></blockquote><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>过滤出1~100中平方根是整数的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_sqr</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> math.sqrt(x) % <span class="hljs-number">1</span> == <span class="hljs-number">0</span><br> <br>tmplist = <span class="hljs-built_in">filter</span>(is_sqr, <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>))<br>newlist = <span class="hljs-built_in">list</span>(tmplist)<br><span class="hljs-built_in">print</span>(newlist)<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>]<br></code></pre></td></tr></table></figure><h2 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h2><p>format 函数可以接受不限个参数，位置可以不按顺序。</p><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)    <span class="hljs-comment"># 不设置指定位置，按默认顺序</span><br><span class="hljs-string">&#x27;hello world&#x27;</span><br> <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)  <span class="hljs-comment"># 设置指定位置</span><br><span class="hljs-string">&#x27;hello world&#x27;</span><br> <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)  <span class="hljs-comment"># 设置指定位置</span><br><span class="hljs-string">&#x27;world hello world&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name=<span class="hljs-string">&quot;菜鸟教程&quot;</span>, url=<span class="hljs-string">&quot;www.runoob.com&quot;</span>))<br> <br><span class="hljs-comment"># 通过字典设置参数</span><br>site = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;菜鸟教程&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;www.runoob.com&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="hljs-built_in">format</span>(**site))<br> <br><span class="hljs-comment"># 通过列表索引设置参数</span><br>my_list = [<span class="hljs-string">&#x27;菜鸟教程&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;</span>.<span class="hljs-built_in">format</span>(my_list))  <span class="hljs-comment"># &quot;0&quot; 是必须的</span><br></code></pre></td></tr></table></figure><h2 id="getattr-obhect-name-default"><a href="#getattr-obhect-name-default" class="headerlink" title="getattr(obhect,name[,default])"></a>getattr(obhect,name[,default])</h2><p>用于返回一个对象的属性值，可以是属性也可是函数，获取的属性值可以直接调用</p><h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):        <br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self, a, b</span>):<br><span class="hljs-meta">... </span>        x = a        <br><span class="hljs-meta">... </span>        a = b        <br><span class="hljs-meta">... </span>        b = x        <br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span> a, b   <br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = A()                 <br><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-built_in">getattr</span>(a, <span class="hljs-string">&#x27;set&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>c(a=<span class="hljs-string">&#x27;1&#x27;</span>, b=<span class="hljs-string">&#x27;2&#x27;</span>)<br><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br></code></pre></td></tr></table></figure><h2 id="hex-x"><a href="#hex-x" class="headerlink" title="hex(x)"></a>hex(x)</h2><p>将一个指定的数字转换为16进制数</p><h2 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h2><p>input()用于接受键盘输入，返回string类型</p><h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment">#输入三角形的三边长</span><br>a,b,c = (<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入三角形三边的长：&quot;</span>).split())<br>a= <span class="hljs-built_in">int</span>(a)<br>b= <span class="hljs-built_in">int</span>(b)<br>c= <span class="hljs-built_in">int</span>(c)<br><br><span class="hljs-comment">#计算三角形的半周长p</span><br>p=(a+b+c)/<span class="hljs-number">2</span><br><br><span class="hljs-comment">#计算三角形的面积s</span><br>s=(p*(p-a)*(p-b)*(p-c))**<span class="hljs-number">0.5</span><br><br><span class="hljs-comment">#输出三角形的面积</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;三角形面积为：&quot;</span>,<span class="hljs-built_in">format</span>(s,<span class="hljs-string">&#x27;.2f&#x27;</span>))<br></code></pre></td></tr></table></figure><p>其中如果要想输入多个参数，请用如下格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a,b,c = (<span class="hljs-built_in">input</span>().split())<br></code></pre></td></tr></table></figure><h2 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h2><p>用于生成一个迭代器</p><h3 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(lst):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-meta">... </span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="map-function-iterable"><a href="#map-function-iterable" class="headerlink" title="map(function,iterable)"></a>map(function,iterable)</h2><p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><blockquote><p>function – 函数<br>iterable – 一个或多个序列</p></blockquote><h3 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(square, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]))   <span class="hljs-comment"># 使用 list() 转换为列表</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br></code></pre></td></tr></table></figure><h2 id="next-iterable-default"><a href="#next-iterable-default" class="headerlink" title="next(iterable[,default])"></a>next(iterable[,default])</h2><p><strong>next()</strong> 返回迭代器的下一个项目。<br><strong>next()</strong> 函数要和生成迭代器的 <strong>iter()</strong> 函数一起使用。</p><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><blockquote><p>iterable – 可迭代对象<br>   default – 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。</p></blockquote><h3 id="举例-7"><a href="#举例-7" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br>it = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>])<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    x = <span class="hljs-built_in">next</span>(it, <span class="hljs-string">&#x27;a&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;a&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br><span class="hljs-number">3</span><br>a<br><br></code></pre></td></tr></table></figure><h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><p>open() 函数用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ad-note">title:注意<br>使用 open() 函数一定要保证关闭文件对象，即调用 close() 函数。<br>open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。<br></code></pre></td></tr></table></figure><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(file, mode=<span class="hljs-string">&#x27;r&#x27;</span>, buffering=-<span class="hljs-number">1</span>, encoding=<span class="hljs-literal">None</span>, errors=<span class="hljs-literal">None</span>, newline=<span class="hljs-literal">None</span>, closefd=<span class="hljs-literal">True</span>, opener=<span class="hljs-literal">None</span>)<br><br></code></pre></td></tr></table></figure><p>参数说明</p><blockquote><p>file: 必需，文件路径（相对或者绝对路径）。<br>mode: 可选，文件打开模式<br>buffering: 设置缓冲<br>encoding: 一般使用utf8<br>errors: 报错级别<br>newline: 区分换行符<br>closefd: 传入的file参数类型<br>opener: None</p></blockquote><p>mode的参数有：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>t</td><td>文本模式 (默认)。</td></tr><tr><td>x</td><td>写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td>b</td><td>二进制模式。</td></tr><tr><td>+</td><td>打开一个文件进行更新(可读可写)。</td></tr><tr><td>U</td><td>通用换行模式（不推荐）。</td></tr><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><h2 id="ord-c"><a href="#ord-c" class="headerlink" title="ord(c)"></a>ord(c)</h2><p>ord() 函数是 chr() 函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。</p><h2 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h2><p><strong>pow()</strong> 方法返回 xy（x的y次方） 的值。<br>math库中也有pow()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ad-note">pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float<br></code></pre></td></tr></table></figure><h2 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h2><h3 id="完整语法"><a href="#完整语法" class="headerlink" title="完整语法"></a>完整语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(*objects, sep=<span class="hljs-string">&#x27; &#x27;</span>, end=<span class="hljs-string">&#x27;\n&#x27;</span>, file=sys.stdout, flush=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><blockquote><p>objects – 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。<br>sep – 用来间隔多个对象，默认值是一个空格。<br>end – 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。<br>file – 要写入的文件对象。<br>flush – 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。</p></blockquote><h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><p>Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。</p><p>Python3 list() 函数是对象迭代器，可以把range()返回的可迭代对象转为一个列表，返回的变量类型为列表。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">range</span>(stop) <span class="hljs-built_in">range</span>(start, stop[, step])<br></code></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><blockquote><p>start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;<br>stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5<br>step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</p></blockquote><h2 id="reversed-seq"><a href="#reversed-seq" class="headerlink" title="reversed(seq)"></a>reversed(seq)</h2><p>reversed 函数返回一个反转的迭代器。</p><h3 id="举例-8"><a href="#举例-8" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br> <br><span class="hljs-comment"># 字符串</span><br>seqString = <span class="hljs-string">&#x27;Runoob&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(seqString)))<br> <br><span class="hljs-comment"># 元组</span><br>seqTuple = (<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(seqTuple)))<br> <br><span class="hljs-comment"># range</span><br>seqRange = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(seqRange)))<br> <br><span class="hljs-comment"># 列表</span><br>seqList = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(seqList)))<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>]<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>]<br>[<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>]<br>[<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="round-x-n"><a href="#round-x-n" class="headerlink" title="round(x[,n])"></a>round(x[,n])</h2><p><strong>round()</strong> 方法返回浮点数 x 的四舍五入值，准确的说保留值将保留到离上一位更近的一端（四舍六入）。</p><p>精度要求高的，不建议使用该函数。</p><h3 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h3><blockquote><p>x – 数字表达式。<br>n – 表示从小数点位数，其中 x 需要四舍五入，默认值为 0。</p></blockquote><h2 id="set-iterable"><a href="#set-iterable" class="headerlink" title="set([iterable])"></a>set([iterable])</h2><p>可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</p><h3 id="举例-9"><a href="#举例-9" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;eleven&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>y = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;twelve&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>x,y<br>(&#123;<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>x &amp; y  <span class="hljs-comment">#交集</span><br>&#123;<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>x | y  <span class="hljs-comment">#并集</span><br>&#123;<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>x - y  <span class="hljs-comment">#差集</span><br>&#123;<span class="hljs-string">&#x27;n&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>y -x   <span class="hljs-comment">#差集</span><br>&#123;<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>x ^ y  <span class="hljs-comment">#补集</span><br>&#123;<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>y ^ x  <span class="hljs-comment">#补集</span><br>&#123;<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>交集 &amp;</strong> : x&amp;y，返回一个新的集合，包括同时在集合 x 和y中的共同元素。</p><p><strong>并集 |</strong> : x|y，返回一个新的集合，包括集合 x 和 y 中所有元素。</p><p><strong>差集 -</strong> : x-y，返回一个新的集合,包括在集合 x 中但不在集合 y 中的元素。</p><p><strong>补集 ^</strong> : x^y，返回一个新的集合，包括集合 x 和 y 的非共同元素。</p><h2 id="setattr-object-name-value"><a href="#setattr-object-name-value" class="headerlink" title="setattr(object,name,value)"></a>setattr(object,name,value)</h2><p>setattr() 函数对应函数 [[内置函数#getattr obhect name default|getattr()]]，用于设置属性值，该属性不一定是存在的。</p><h3 id="举例-10"><a href="#举例-10" class="headerlink" title="举例"></a>举例</h3><p>对已存在的属性进行赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">... </span>    bar = <span class="hljs-number">1</span><br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = A()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(a, <span class="hljs-string">&#x27;bar&#x27;</span>)          <span class="hljs-comment"># 获取属性 bar 值</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">setattr</span>(a, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">5</span>)       <span class="hljs-comment"># 设置属性 bar 值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.bar<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>如果属性不存在会创建一个新的对象属性，并对属性赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br><span class="hljs-meta">... </span>    name = <span class="hljs-string">&quot;runoob&quot;</span><br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = A()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">setattr</span>(a, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">28</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a.age)<br><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h2 id="sorted-iterable-key-x3D-None-reverse-x3D-False"><a href="#sorted-iterable-key-x3D-None-reverse-x3D-False" class="headerlink" title="sorted(iterable,key&#x3D;None,reverse&#x3D;False)"></a>sorted(iterable,key&#x3D;None,reverse&#x3D;False)</h2><p><strong>sorted()</strong> 函数对所有可迭代的对象进行排序操作。并且返回重新排序的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ad-note">title:sort 与 sorted 的区别<br>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。<br>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。<br></code></pre></td></tr></table></figure><h3 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h3><blockquote><p>iterable – 可迭代对象。<br>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。<br>reverse – 排序规则，reverse &#x3D; True 降序 ， reverse &#x3D; False 升序（默认）。</p></blockquote><h2 id="sum-iterable-start"><a href="#sum-iterable-start" class="headerlink" title="sum(iterable[,start])"></a>sum(iterable[,start])</h2><p><strong>sum()</strong> 方法对序列进行求和计算。</p><h3 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h3><blockquote><p>iterable – 可迭代对象，如：列表、元组、集合。<br>start – 指定相加的参数，如果没有设置这个值，默认为0。</p></blockquote><h2 id="super-type-object-or-type"><a href="#super-type-object-or-type" class="headerlink" title="super(type[,object or type])"></a>super(type[,object or type])</h2><p><strong>super()</strong> 函数是用于调用父类(超类)的一个方法。</p><p><strong>super()</strong> 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p><p>MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。</p><h3 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h3><blockquote><p>type – 类。<br>object-or-type – 类，一般是 self</p></blockquote><h3 id="举例-11"><a href="#举例-11" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>):<br>         y = x+<span class="hljs-number">1</span><br>         <span class="hljs-built_in">print</span>(y)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-built_in">super</span>().add(x)<br>b = B()<br>b.add(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><h2 id="tuple-iterable"><a href="#tuple-iterable" class="headerlink" title="tuple(iterable)"></a>tuple(iterable)</h2><p>tuple 函数将可迭代系列（如列表）转换为元组。</p><h3 id="举例-12"><a href="#举例-12" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a= <span class="hljs-string">&#x27;www&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b=<span class="hljs-built_in">tuple</span>(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br>(<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a=&#123;<span class="hljs-string">&#x27;www&#x27;</span>:<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;aaa&#x27;</span>:<span class="hljs-number">234</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>b=<span class="hljs-built_in">tuple</span>(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)   <span class="hljs-comment"># 将字段转换为元组时，只保留键！</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a=<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (a)<br>&#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>b=<span class="hljs-built_in">tuple</span>(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br>(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验总结</category>
      
      <category>技术知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
