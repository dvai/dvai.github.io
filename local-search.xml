<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小区路口的理发师</title>
    <link href="/2022/10/29/%E5%B0%8F%E5%8C%BA%E8%B7%AF%E5%8F%A3%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88/"/>
    <url>/2022/10/29/%E5%B0%8F%E5%8C%BA%E8%B7%AF%E5%8F%A3%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<p>我的小区路口有一家理发店，理发的价格是15元一次。自从在县城理发付了70元的学费后我便成为小区门口理发店的常客。</p><p>这间理发店十分简陋，门口总是摆放着一辆黑色的敞篷小三轮，大概是他的交通工具，走进理发店，大约20平米的空间只简单摆放了几件沾满时光气息的家具以及一些理发工具。仔细闻闻，空气中还夹带着几丝腐败的难闻气息。</p><p>店主是一位约莫30来岁的细瘦男子，留着一头微卷的中分。每当我踏进门，他都会停下手里的工作，甩甩头发笑着说，“稍微坐一会儿哦，我这个很快就好。”</p><p>我一向不喜欢和理发师多沟通，只想安安静静的坐着，等待理发师剪好头发，然后离开。然而大部分理发师总喜欢和你闲聊几句，有些会和你聊聊工作八卦之类的家常，离谱的直接给你推荐几套会员卡套餐。</p><p>但是这个理发师却很安静，每次理发只是简单招呼我先过去洗个头，然后问我想怎么打理头发，接着便默默地开始他的工作。随着次数增多，话语更是精简到只剩开局的一句“和往常一样吗？”。</p><p>深得我心。</p><p>我曾经以为他就是这么一个不善言辞的人，直到有一次前去理发，听见他和座椅上的大妈闲聊地有来有回，我这才知道，原来他并非不善言辞，只不过是在照顾不同顾客的习惯罢了。</p><p>由此看来我其实和这个理发师并没有什么过多的交集，我不曾和他深入交流过，只不过偶尔从他和客人之间的谈话中听得一些事。</p><p>听闻他30多岁一直没有女朋友，后来在亲戚介绍下与一个离异带孩的女子草草结了婚。</p><p>他是这么说的，</p><p>“我也已经老大不小了，自己的条件不怎么样也不能对别人要求太高。何况这个女子人也不错，也是该有个家了。”</p><p>此处所说的女子我也见过几次，是一个身体有些发福的中年女人。有时她会抱着孩子坐在一旁的破旧沙发上，望着怀中酣睡的小孩，轻轻摇晃臂弯。眉眼之间尽是温柔。</p><p>上周，我在县城的街上与他偶遇，他坐在小三轮上停靠在路边，我走向前和他打招呼。</p><p>“呦！我也是xx小区的，去你那儿理过几次头发。你在这儿干嘛呢？”</p><p>他见着我，先是愣了一会儿，然后开心地说，“哦……哦！我带小孩子打针，老婆在上厕所，我在等她。”</p><p>我看向他的怀中，即使在吵闹的街区，孩子依然睡的十分安稳。</p><p>简单寒喧几句过后我说自己要走了，他像是巧遇故友却又要分别一样，热情地同我道别。</p><p>我不曾了解他的生活，不过我记得当时离开的路上，心情不错。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活小事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用ffmpeg推送RTMP流</title>
    <link href="/2022/10/29/%E4%BD%BF%E7%94%A8ffmpeg%E6%8E%A8%E9%80%81RTMP%E6%B5%81/"/>
    <url>/2022/10/29/%E4%BD%BF%E7%94%A8ffmpeg%E6%8E%A8%E9%80%81RTMP%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单位最近好像有网络直播的需要，说起网络直播，最常见的就是通过RTMP协议进行网络推流。 ffmpeg是一款开源的图像处理项目，可以方便的进行图像视频处理，推送操作，当然我们需要的推送RTMP流功能也可以很好的实现。 本文就以ffmpeg为工具进行RTMP的推送。</p><h2 id="安装ffmpeg"><a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装ffmpeg</h2><ol><li>在官网下载ffmpeg压缩包：<a href="http://ffmpeg.org/download.html">下载链接</a></li><li>解压到本地磁盘</li><li>将解压后的bin文件夹路径配置到系统环境变量中</li><li>打开cmd输入<code>ffmpeg –version</code>，可以看到ffmpeg的相关信息即可</li></ol><h2 id="配置RTMP服务器"><a href="#配置RTMP服务器" class="headerlink" title="配置RTMP服务器"></a>配置RTMP服务器</h2><ol><li>安装nginx，<a href="http://nginx.org/">下载地址</a></li><li>下载nginx-rtmp，<a href="https://github.com/illuspas/nginx-rtmp-win32">下载地址</a>下载后解压放到与nginx的同级目录</li><li>复制nginx的conf文件夹中的nginx-win.conf文件，在其末尾添加</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">rtmp &#123;<br>    server &#123;<br>        listen 1935;#监听端口,若被占用,可以更改<br>        chunk_size 4000;#上传flv文件块儿的大小<br>        application live &#123; #创建一个叫live的应用<br>             live on;#开启live的应用<br>             allow publish 127.0.0.1;#<br>             allow play all;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>以下代码可以实现将本地的视频以RTMP流的方式推送到RTMP服务器，实现网络直播。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">import cv2<br>import subprocess<br><br> camera_path = r&quot;本地视频地址&quot;<br><br> # 视频读取对象<br> cap = cv2.VideoCapture(camera_path) <br><br> # 读取一帧<br> ret, frame = cap.read()<br><br> # 推流地址<br> rtmp = &quot;RTMP服务器地址&quot;<br><br> fps = int(cap.get(cv2.CAP_PROP_FPS))<br> width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))<br> height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))<br> # 推流参数<br> command = [&#x27;D:\\ffmpeg\\bin\\ffmpeg.exe&#x27;,<br>    &#x27;-y&#x27;,<br>    &#x27;-f&#x27;, &#x27;rawvideo&#x27;,<br>    &#x27;-vcodec&#x27;,&#x27;rawvideo&#x27;,<br>    &#x27;-pix_fmt&#x27;, &#x27;bgr24&#x27;,<br>    &#x27;-s&#x27;, &quot;&#123;&#125;x&#123;&#125;&quot;.format(width, height),<br>    &#x27;-r&#x27;, str(fps),<br>    &#x27;-i&#x27;, &#x27;-&#x27;,<br>    &#x27;-c:v&#x27;, &#x27;libx264&#x27;,<br>    &#x27;-pix_fmt&#x27;, &#x27;yuv420p&#x27;,<br>    &#x27;-preset&#x27;, &#x27;ultrafast&#x27;,<br>    &#x27;-f&#x27;, &#x27;flv&#x27;, <br>    rtmp]<br><br> # 创建、管理子进程<br> pipe = subprocess.Popen(command, stdin=subprocess.PIPE)<br> size = (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), <br> int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))<br><br> # 循环读取<br> while cap.isOpened():<br>    # 读取一帧<br>    ret, frame = cap.read()<br>    if frame is None:<br>    print(&#x27;read frame err!&#x27;)<br>    continue<br>    <br>    # 显示一帧<br>    cv2.imshow(&quot;frame&quot;, frame)<br>    <br>    # 按键退出<br>    if cv2.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;):<br>    break<br><br>    # 读取尺寸、推流<br>    img=cv2.resize(frame,size)<br>    pipe.stdin.write(img.tobytes()) <br><br> cv2.destroyAllWindows()<br><br> cap.release()<br></code></pre></td></tr></table></figure><p>启动程序后，使用VLC或者Potplayer等软件读取RTMP地址即可播放。</p><h2 id="ffmpeg-python包"><a href="#ffmpeg-python包" class="headerlink" title="ffmpeg-python包"></a>ffmpeg-python包</h2><p>通过以上代码确实能够实现ffmpeg的推流，不过实际上只是调用了ffmpeg自带的命令行工具，更改参数什么的不太方便，后来了解到python有ffmpeg的包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">pip install ffmpeg-python<br></code></pre></td></tr></table></figure><p>关于ffmpeg包的使用，下次再另写一篇文章。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>技术经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 开机挂载磁盘和swap分区</title>
    <link href="/2022/10/10/linux%20%E5%BC%80%E6%9C%BA%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98%E5%92%8Cswap%E5%88%86%E5%8C%BA/"/>
    <url>/2022/10/10/linux%20%E5%BC%80%E6%9C%BA%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98%E5%92%8Cswap%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近manjaro经常内存爆满，16G的物理内存理应来说是够的，但是不知道为什么有时候某个软件会突然占用过高的内存，后来发现是没有启用swap分区，但不知能否解决内存溢出的问题，先记下启用swap分区的方法。 Linux 中的 Swap 交换分区就是 Windows 中的虚拟内存，将Linux系统服务器中的物理硬盘空间虚拟化成内存使用，以解决内存不够的问题。不同的Linux【CentOS&#x2F;Ubuntu&#x2F;Debian】发行版新建，增加 Swap 分区的方法是一样的，下面致臻数据就分享下如何确定和创建 Swap 分区及大小。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="swap分区需要的大小"><a href="#swap分区需要的大小" class="headerlink" title="swap分区需要的大小"></a>swap分区需要的大小</h3><ol><li>&lt;&#x3D; 4g 至少 4G</li><li>4~16G 至少 8G</li><li>16G~64G 至少 16G</li><li>64G~256G 至少 32G</li></ol><h3 id="创建swap分区"><a href="#创建swap分区" class="headerlink" title="创建swap分区"></a>创建swap分区</h3><p>创建命令如下，其中 &#x2F;var&#x2F;swapfile 是文件位置，bs*count 是文件大下，比如我创建一个 16G 的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">dd if=/dev/zero of=/var/swapfile bs=4M count=4096<br></code></pre></td></tr></table></figure><h3 id="建立swap文件系统"><a href="#建立swap文件系统" class="headerlink" title="建立swap文件系统"></a>建立swap文件系统</h3><p>将文件格式化为swap分区文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">mkswap /var/swapfile<br></code></pre></td></tr></table></figure><h3 id="启用swap分区"><a href="#启用swap分区" class="headerlink" title="启用swap分区"></a>启用swap分区</h3><p>启用分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">swapon /var/swapfile<br></code></pre></td></tr></table></figure><p>查看是否成功启用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">free -m<br></code></pre></td></tr></table></figure><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><p>编辑<code>/etc/fstab</code>文件，在文件末尾加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">/var/swapfile swap swap defaults 0 0<br></code></pre></td></tr></table></figure><p>注意：中间用tab分割</p><h3 id="修改swappiness参数"><a href="#修改swappiness参数" class="headerlink" title="修改swappiness参数"></a>修改swappiness参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">vim /proc/sys/vm/swappiness<br></code></pre></td></tr></table></figure><p>内容的值来确定系统对 SWAP 分区的使用原则。当 swappiness 内容的值为 0 时，表示最大限度地使用物理内存，物理内存使用完毕后，才会使用 SWAP 分区。当 swappiness 内容的值为 100 时，表示积极地使用 SWAP 分区，并且把内存中的数据及时地置换到 SWAP 分区。 查看修改前为 0，需要在物理内存使用完毕后才会使用 SWAP 分区。 可以使用下述方法临时修改此参数，假设我们配置为空闲内存少于 15% 时才使用 SWAP 分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">echo 15 &gt;/proc/sys/vm/swappiness<br></code></pre></td></tr></table></figure><p>若需要永久修改此配置，在系统重启之后也生效的话，可以修改 <code>/etc/sysctl.conf</code> 文件，并增加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">vm.swappiness=15<br></code></pre></td></tr></table></figure><h3 id="挂载机械硬盘"><a href="#挂载机械硬盘" class="headerlink" title="挂载机械硬盘"></a>挂载机械硬盘</h3><p>也是编辑<code>/etc/fstab</code>文件 在末尾加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text-plain">/dev/sda1 /data ntfs defaults 0 0<br></code></pre></td></tr></table></figure><p>配置完成后可用<code>sudo mount -a</code>检查是否配置成功</p><h3 id="为某个用户挂载"><a href="#为某个用户挂载" class="headerlink" title="为某个用户挂载"></a>为某个用户挂载</h3><p>加入uid和gid参数，查看当前用户的uid的指令为<code>id</code></p><h2 id="etc-fstab详解"><a href="#etc-fstab详解" class="headerlink" title="etc/fstab详解"></a><code>etc/fstab</code>详解</h2><h4 id="文件作用"><a href="#文件作用" class="headerlink" title="文件作用"></a>文件作用</h4><p>磁盘被手动挂载之后都必须把挂载信息写入&#x2F;etc&#x2F;fstab这个文件中，否则下次开机启动时仍然需要重新挂载。  系统开机时会主动读取&#x2F;etc&#x2F;fstab文件中的内容，根据文件这个里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。  </p><h4 id="挂载的限制"><a href="#挂载的限制" class="headerlink" title="挂载的限制"></a>挂载的限制</h4><ol><li>根目录是必须挂载的，而且一定要先于其他mount point被挂载。因为mount是所有目录的跟目录，其他木有都是由根目录 &#x2F;衍生出来的。</li><li>挂载点必须是已经存在的目录。</li><li>挂载点的指定可以任意，但必须遵守必要的系统目录架构原则</li><li>所有挂载点在同一时间只能被挂载一次</li><li>所有分区在同一时间只能挂在一次</li><li>若进行卸载，必须将工作目录退出挂载点（及其子目录）之外。</li></ol><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>label或uid 用唯一名称定位需要挂载的分区或磁盘</p><p>挂载点 需要挂载到哪个目录下</p><p>磁盘的系统</p><p>文件系统的参数</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Async&#x2F;sync</td><td>设置是否为同步方式运行，默认为 async</td></tr><tr><td>auto&#x2F;noauto</td><td>当下载 mount -a 的命令时，此文件系统是否被主动挂载。默认为 auto</td></tr><tr><td>rw&#x2F;ro</td><td>是否以以只读或者读写模式挂载</td></tr><tr><td>exec&#x2F;noexec</td><td>限制此文件系统内是否能够进行 “执行” 的操作</td></tr><tr><td>user&#x2F;nouser</td><td>是否允许用户使用 mount 命令挂载</td></tr><tr><td>suid&#x2F;nosuid</td><td>是否允许 SUID 的存在</td></tr><tr><td>Usrquota</td><td>启动文件系统支持磁盘配额模式</td></tr><tr><td>Grpquota</td><td>启动文件系统对群组磁盘配额模式的支持</td></tr><tr><td>Defaults</td><td>同事具有 rw,suid,dev,exec,auto,nouser,async 等默认参数的设置</td></tr></tbody></table><p>dump 是否使用dump备份，0表示不需要，1表示每天，2表示不定日期，备份我一般使用其他方式，所以填0就好</p><p>是否检验 0表示不需要，1表示最早（一般根目录需要），2表示1级别完成之后进行检验</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
